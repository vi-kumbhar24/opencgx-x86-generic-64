Index: evlog-1.6.1/user/cmd/evlconfig/evlconfig.c
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlconfig/evlconfig.c
+++ evlog-1.6.1/user/cmd/evlconfig/evlconfig.c
@@ -50,6 +50,7 @@ const char *progname;
 
 typedef struct options {
 	int	conflist;
+	char	*newlog;		/* new log ID string */
 	char	*scr_filter;
 	int	dcount;			/* 0 = infinite count */
 	int	dinterval;		/* 0 = infinite interval */
@@ -58,7 +59,7 @@ typedef struct options {
 	int	sev_level;		/* -1 = disable console message */
 } options_t;
 
-static options_t cmd_opt = {0, NULL, -1, -1, -1, NULL, 0xbad};
+static options_t cmd_opt = {0, NULL, NULL, -1, -1, -1, NULL, 0xBAD};
 
 #define ACCESS_OK(pid) (getuid() == pid)
 
@@ -68,7 +69,8 @@ static options_t cmd_opt = {0, NULL, -1,
 #define SEV_LEVEL		2
 #define LOOKBACK_SIZE		3
 #define DIS_DUPS		4
-#define EVENT_SCREEN		5
+#define NEWLOG			5
+#define EVENT_SCREEN		6
 
 #define MAX_DUP_INTERVAL        3600
 #define MAX_DUP_COUNT           10000
@@ -89,6 +91,7 @@ usage()
 	(void) fprintf(stderr, "\t-L | --lookbacks size\n");
 	(void) fprintf(stderr, "\t-s | --screen filter | nofilter\n");
 	(void) fprintf(stderr, "\t-o | --output severity-level | off\n");
+	(void) fprintf(stderr, "\t-n | --newlog no-id | id=string\n");
 	(void) fprintf(stderr, "\t--help\n");
 	(void) fprintf(stderr, "\n");
 
@@ -125,6 +128,24 @@ get_cmd_opts(int argc, char **argv, opti
 		} else if (!strcmp(argv[i], "--list") ||
 						!strcmp(argv[i], "-l")) {
 			optp->conflist = 1;
+		}
+		else if (!strcmp(argv[i], "--newlog") ||
+						!strcmp(argv[i], "-n")) {
+			if ((argc - i) == 1) {
+				usage();
+			}
+
+			i++;
+
+			if (strcmp(argv[i], "no-id") == 0) {
+				optp->newlog = "";
+			}
+			else if (strncmp(argv[i], "id=", 3) == 0) {
+				optp->newlog = argv[i] + 3;
+			}
+			else {
+				usage();
+			}
 		} else if (!strcmp(argv[i], "--lookbacks") ||
 						!strcmp(argv[i], "-L")) {
 			if ((argc - i) == 1) {
@@ -471,7 +492,7 @@ evlconf_ops(int fd, int sd)
 			goto out;
 		}
 	}
-	if (cmd_opt.sev_level != 0xbad) {
+	if (cmd_opt.sev_level != 0xBAD) {
 		snprintf(wrbuf, sizeof(wrbuf), "%d", cmd_opt.sev_level);
 		if ((error = updateConfValues(fd, fp, sd, SEV_LEVEL, 
 				cmd_opt.sev_level, wrbuf, strlen(wrbuf),
@@ -521,6 +542,101 @@ out:
 	return (error);
 }
 
+/*
+ * FUNCTION     : evlnewlog
+ *
+ * PURPOSE      : Connect to the evlogd daemon. Send a new log command to
+ *		: the daemon.
+ *
+ * RETURN       : returns 0 for success. otherwise returns -1
+ */
+
+static int
+evlnewlog(int sd, char *id)
+{
+	struct sockaddr_un	sa;
+	int			value;
+
+	int			type = NEWLOG;
+	int			end_tran = EVENT_SCREEN + 1;
+
+	/*
+	 * Attempt to scrounge up a connection.
+	 */
+
+	if ((sd = _establishNonBlkConnection(EVLOG_CONF_SOCKET, &sa,
+							1 /*timeout*/)) < 0) {
+		(void) fprintf(stderr, "%s: Unable to establish connection\n",
+								progname);
+
+		exit(1);
+	}
+
+	/*
+	 * Send the the command to evlogd.
+	 */
+
+	if (write(sd, &type, sizeof(int)) != sizeof(int)) {
+		(void) fprintf(stderr, "%s: Failed to write on socket\n",
+								progname);
+
+		return (-1);
+	}
+
+	/*
+	 * Send the the ID string length to evlogd.
+	 */
+
+	value = strlen(id) + 1;
+
+	if (write(sd, &value, sizeof(int)) != sizeof(int)) {
+		(void) fprintf(stderr, "%s: Failed to write on socket\n",
+								progname);
+
+		return (-1);
+	}
+
+	/*
+	 * Send the the ID string to evlogd (NUL included).
+	 */
+
+	if (write(sd, (void *) id, value) != value) {
+		(void) fprintf(stderr, "%s: Failed to write on socket\n",
+								progname);
+
+		return (-1);
+	}
+
+	/*
+	 * Send the end of transmission value to evlogd.
+	 */
+
+	if (write(sd, &end_tran, sizeof(int)) != sizeof(int)) {
+		(void) fprintf(stderr, "%s: Failed to write on socket\n",
+								progname);
+
+		return (-1);
+	}
+
+	/*
+	 * Wait for the completion status.
+	 */
+
+	if (read(sd, (void *) &value, sizeof(int)) != sizeof(int)) {
+		(void) fprintf(stderr, "%s: Failed to read from socket\n",
+								progname);
+
+		return (-1);
+	}
+
+	if (value != 0) {
+		(void) fprintf(stderr, "%s: command failure: %d\n",
+							progname, value);
+	}
+
+	return (value);
+}
+
 main(int argc, char **argv)
 {
 	char *p;
@@ -541,7 +657,7 @@ main(int argc, char **argv)
 		(cmd_opt.dnumdups >= 0) ||
 		(cmd_opt.dis_on != (char *)NULL) ||
 		(cmd_opt.scr_filter != (char *)NULL) ||
-		(cmd_opt.sev_level != 0xbad)) {
+		(cmd_opt.sev_level != 0xBAD)) {
 		/*
 		 * Only root has permission to modify evlog.conf file.
 		 */
@@ -579,6 +695,37 @@ main(int argc, char **argv)
 			exit(1);
 		}
 	}
+
+	if (cmd_opt.newlog != (char *) NULL) {
+		/*
+		 * Only root has permission to start a new log file.
+		 */
+		if (!ACCESS_OK(0)) {
+			(void) fprintf(stderr,
+		"%s: Only root has permission to start a new log file\n",
+				progname);
+			exit(1);
+		}
+
+		if ((sd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {
+			(void) fprintf(stderr,
+				"%s: cannot create 'evlogd' socket.\n",
+				progname);
+			perror("socket");
+			return -1;
+		}
+		if (fcntl(sd, F_SETFL, O_NONBLOCK) < 0) {
+			perror("fcntl");
+			(void) close(sd);
+			return -1;
+		}
+		estatus = evlnewlog(sd, cmd_opt.newlog);
+		(void) close(sd);
+
+		if (estatus != 0) {
+			exit(1);
+		}
+	}
 	if (cmd_opt.conflist) {
 		char line[MAX_EVL_LINE];
 		FILE *conf_f;
Index: evlog-1.6.1/user/cmd/evlogd/evlogd.c
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogd/evlogd.c
+++ evlog-1.6.1/user/cmd/evlogd/evlogd.c
@@ -30,6 +30,7 @@
 #include <strings.h>  	/* Defines bcopy() */
 #include <errno.h>      /* Defines errno */
 #include <signal.h>     /* Defines signal handler structures */
+#include <time.h>	/* Defines time parameters */
 #include <unistd.h>     /* Defines fork() */
 #include <malloc.h>     /* Defines malloc() */
 #include <stdlib.h>     /* Defines atexit() and exit() */
@@ -131,21 +132,23 @@ _syscall3(int,ksyslog,int, type, char *,
 #define SEV_LEVEL	2
 #define DIS_SIZE	3
 #define DIS_DUPS	4
-#define EVENT_SCREEN	5
+#define NEWLOG		5
+#define EVENT_SCREEN	6
 
 #define MAX(a,b) (((a) > (b)) ? (a) : (b))
+
 #ifdef DEBUG2
-#define TRACE(fmt, args...)		fprintf(stdout, fmt, ##args)
+#define TRACE(fmt, args...)	fprintf(stdout, fmt, ##args)
 #else
-#define TRACE(fmt, args...)		/* fprintf(stdout, fmt, ##args) */
+#define TRACE(fmt, args...)	/* fprintf(stdout, fmt, ##args) */
 #endif
 
 #define MAX_USER_EVLBUF		512 * 1024
-#define MAX_USERPRIV_EVLBUF		256 * 1024
+#define MAX_USERPRIV_EVLBUF	256 * 1024
 
-#define MAX_CLIENTS					240
-#define CLIENT_SLOT_AVAILABLE		-1
-#define SHMSZ		4
+#define MAX_CLIENTS		240
+#define CLIENT_SLOT_AVAILABLE	-1
+#define SHMSZ			4
 
 typedef struct clientinfo {
 	int sd;
@@ -170,6 +173,7 @@ static int maxci;
 static pid_t kpid = 0;
 static pid_t rmtdpid = 0;
 
+char *ProgName;
 char * sharedData;
 int waitForKids = 1;
 
@@ -186,7 +190,8 @@ void getRecHeader(const char *buf, struc
 
 /* backendmgr */
 extern int be_init(void);
-extern void be_run(const char *data1, const char *data2, evl_callback_t callback);
+extern void be_run(const char *data1, const char *data2,
+						evl_callback_t callback);
 extern void be_cleanup(void);
 
 typedef struct userbuf_info {
@@ -236,11 +241,11 @@ int dup_array_size = DEFAULT_DUP_ARRAY_S
 int dis_dup_recs = TRUE;
 int debug_on     = TRUE;
 int Process_kernel_events = TRUE;
-int console_sev_level = CONSOLE_OUTPUT_DISABLE;		/* default is disable */
+int console_sev_level = CONSOLE_OUTPUT_DISABLE;	/* default is disable */
 char query_exp[MAX_EVL_LINE];
 posix_log_query_t dis_query;
 
-static int notify_sd = 0;     /* socket descriptor for communicate with notification daemon */
+static int notify_sd = 0;     /* notification daemon socket descriptor */
 int maxsd;
 fd_set all_sds;
 fd_set read_sds;
@@ -258,11 +263,11 @@ static int Process_Event(clientinfo_t *)
 static int log_evl_rec(log_info_t *, char *);
 static int openMaybeCreate(const char *, mode_t , log_info_t *);
 static void mk_evl_rec(log_info_t *linfo, posix_log_facility_t, int, 
-					   posix_log_severity_t, const char *, ...);
+			   posix_log_severity_t, const char *, ...);
 static int updateConfvalues(int);
 static void writeEvtToNfyDaemon(char *lbuf);
 static int createSocket(char *sockname, int *sd, socklen_t *sock_len, 
-						struct sockaddr_un *sa, mode_t mode, int backlog);
+			struct sockaddr_un *sa, mode_t mode, int backlog);
 static int rmSocket(int);
 
 static void dumpDuplicatesBuffer(log_info_t *);
@@ -273,7 +278,6 @@ static int compute_score(dup_buffer_t *,
 int writeEx(int sd, void * buf, size_t len);
 int lock_routine(int fd, int cmd, int type);
 int isRTC_Local();
-char *getProcessCmd(pid_t pid);
 void reload_daemon();
 
 static char *confPath = LOG_EVLOG_CONF_DIR "/evlog.conf";
@@ -290,8 +294,8 @@ static char * system_map = NULL;/* your 
    Return 1 if the difference is negative, otherwise 0.  */
 
 int
-timeval_subtract (result, x, y)
-     struct timeval *result, *x, *y;
+timeval_subtract(struct timeval *result, struct timeval *x,
+							struct timeval *y)
 {
 	/* Perform the carry for the later subtraction by updating y. */
 	if (x->tv_usec < y->tv_usec) {
@@ -329,8 +333,8 @@ _daemonize()
 	 * the first child is not a process group leader.
 	 */
 	if ((pid = fork()) < 0) {
-		fprintf(stdout, 
-				"evlogd: Cannot fork child process. Check system process usage.\n"); 
+		(void) fprintf(stderr, "%s: Cannot fork child process.\n",
+					ProgName);
 		exit(1);
 	} else if (pid > 0) {
 		exit (0);
@@ -352,8 +356,8 @@ _daemonize()
 	(void)signal(SIGHUP, SIG_IGN);
 
 	if ((pid = fork()) < 0) {
-		fprintf(stderr,
-				"evlogd: Cannot fork child process. Check system process usage.\n"); 
+		(void) fprintf(stderr, "%s: Cannot fork child process.\n",
+					ProgName);
 		exit(1);
 	} else if (pid > 0) {
 		exit(0);
@@ -363,8 +367,9 @@ _daemonize()
 	/* stuck my process id away */
 	if (!_evlUpdate_pid(PidFile)) {
 		mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_WRITE_PID, 
-				   LOG_CRIT,"evlogd: Cannot write 'evlogd' PID to '%s' file\n",
-				   PidFile); 
+				LOG_CRIT,
+				"%s: Cannot write PID to '%s' file\n",
+				ProgName, PidFile);
 		exit(1);
 	}
 
@@ -395,27 +400,26 @@ _daemonize()
 }
 
 /* 
- * Initialize the log files (eventlog and privatelog)
+ * Open the log files (eventlog and privatelog)
  */
+
 void
-initLogFiles()
+openLogFiles()
 {
-	static char log_file_name[FILENAME_MAX] = LOG_CURLOG_PATH;
-	static char privatelog[FILENAME_MAX] = LOG_PRIVATE_PATH;
-	
-	memset(&dis_query, 0, sizeof(posix_log_query_t));
 	memset(&evl_log, 0, sizeof(log_info_t));
-	if (openMaybeCreate(log_file_name, 0644, &evl_log) < 0) {
+
+	if (openMaybeCreate(LOG_CURLOG_PATH, 0644, &evl_log) < 0) {
 		if (evl_log.fd >= 0) {
 			(void) flock(evl_log.fd, LOCK_UN);
-			close(evl_log.fd);	
+			close(evl_log.fd);
 		}
 		exit(1);
 	}
 	user_evlbuf.fd = evl_log.fd;
 
 	memset(&pvt_log, 0, sizeof(log_info_t));
-	if (openMaybeCreate(privatelog, 0600, &pvt_log) < 0) {
+
+	if (openMaybeCreate(LOG_PRIVATE_PATH, 0600, &pvt_log) < 0) {
 		if (pvt_log.fd >= 0) {
 			(void) flock(pvt_log.fd, LOCK_UN);
 			close(pvt_log.fd);
@@ -426,7 +430,6 @@ initLogFiles()
 
 	if (pvt_log.recId == 0 && evl_log.recId == 0) {
 		gRecId = 0;
-		
 	} else {
 		gRecId = MAX(pvt_log.recId, evl_log.recId);
 	}
@@ -437,11 +440,23 @@ initLogFiles()
 	 */
 	evl_log.recId = 1;	
 	pvt_log.recId = 0;
-	
+}
+
+/*
+ * Initialize the log files (eventlog and privatelog)
+ */
+void
+initLogFiles()
+{
+	(void) memset(&dis_query, 0, sizeof(posix_log_query_t));
+
+	openLogFiles();
+
 	/* Initially the query tree is null */
 	dis_query.qu_tree = NULL;
 	if (readEvlogConfig() != 0) {
-		fprintf(stderr, "evlogd: Read config file failed\n");
+		(void) fprintf(stderr, "%s: Read config file failed\n",
+				ProgName);
 		exit(1);
 	}
 }
@@ -472,28 +487,30 @@ initSharedMem()
 void
 initSignals()
 {
-	
-	static struct sigaction SigAllAction; /* Signal handler to terminate gracefully */
 	static struct sigaction act;
 	static struct sigaction SigChild; 	  /* Signal handler SIGCHLD */
+	static struct sigaction SigAllAction;
+
 	void sigChild_handler();
 	void NewSIGAction();
-	
+
 	(void)memset(&SigAllAction, 0, sizeof(struct sigaction));
+
+	/* Signal handler to terminate gracefully */
 	SigAllAction.sa_handler = NewSIGAction;
 	SigAllAction.sa_flags = 0;
 
 	if (sigaction(SIGTERM, &SigAllAction, NULL) < 0){
 		mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SIG_ACT, LOG_WARNING,
-				   "evlogd: WARNING - sigaction failed for SIGTERM.\n"); 
+		"%s: WARNING - sigaction failed for SIGTERM.\n", ProgName);
 	}
 	if (sigaction(SIGINT, &SigAllAction, NULL) < 0){
 		mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SIG_ACT, LOG_WARNING,
-				   "evlogd: WARNING - sigaction failed for new SIGINT.\n"); 
+		"%s: WARNING - sigaction failed for new SIGINT.\n", ProgName);
 	}
 	if (sigaction(SIGHUP, &SigAllAction, NULL) < 0){
 		mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SIG_ACT, LOG_WARNING,
-				   "evlogd: WARNING - sigaction failed for new SIGHUP.\n");
+		"s: WARNING - sigaction failed for new SIGHUP.\n", ProgName);
 	}
 
 	/*
@@ -504,7 +521,7 @@ initSignals()
 	SigChild.sa_flags = 0;
 	if (sigaction(SIGCHLD, &SigChild, NULL) < 0){
 		mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SIG_ACT, LOG_WARNING,
-				   "evlogd: WARNING - sigaction failed for SIGCHLD.\n"); 
+		"%s: WARNING - sigaction failed for SIGCHLD.\n", ProgName);
 	}
 
 	/* Ignore SIGUSR1, SIGUSR2 except process kpid */
@@ -516,7 +533,8 @@ initSignals()
 	act.sa_handler = SIG_IGN;
 	act.sa_flags = 0;
 	if (sigaction(SIGPIPE, &act, NULL) < 0){
-		(void)fprintf(stderr, "evlogd: sigaction failed for new SIGPIPE.\n");
+		(void) fprintf(stderr,
+			"%s: sigaction failed for new SIGPIPE.\n", ProgName);
 		perror("sigaction");
 		exit(1);
 	}
@@ -531,8 +549,7 @@ run_child()
 	int shmid;
 	key_t key;
 	char *shm, *s;
-	
-	
+
 	/* Setting up shared mem */
 	key = 6712;
 	shmid = shmget(key, SHMSZ, IPC_CREAT | 0600);
@@ -564,6 +581,35 @@ run_child()
 	_exit(0);		
 }
 
+static void
+evlogrmtCredCheck(pid_t pid)
+{
+	int	fd;
+	char	proc_path[64];
+
+	(void) sprintf(proc_path, "/proc/%u/cmdline", pid);
+
+	fd = open(proc_path, O_RDONLY);
+
+	if (fd != -1) {
+		size_t	erc;
+		char	cmdline[256 + 1];
+
+		erc = read(fd, (void *) cmdline, (size_t) 256);
+
+		(void) close(fd);
+
+		if (erc > 0) {
+			cmdline[erc] = '\0';
+
+			if (strstr(cmdline, "evlogrmtd"))
+				rmtdpid = pid;
+		}
+	}
+
+	return;
+}
+
 /*
  * The parent infinite loop 
  */
@@ -597,8 +643,8 @@ run_parent(uid_t max_sysuid, int max_use
 	}
 	/* Listen to clients that are writing events to the log */
 	(void)unlink(EVLOGD_EVTSERVER_SOCKET);
-	if (createSocket(EVLOGD_EVTSERVER_SOCKET, &listen_sd, &listen_sock_len,
-					 &listen_sock, 0666, MAX_CLIENTS) < 0) {
+	if (createSocket(EVLOGD_EVTSERVER_SOCKET, &listen_sd,
+		&listen_sock_len, &listen_sock, 0666, MAX_CLIENTS) < 0) {
 		exit(1);
 	}
 
@@ -624,11 +670,15 @@ run_parent(uid_t max_sysuid, int max_use
 		ptv = (tv.tv_sec == 0 ? NULL : &tv);
 
 		if (notify_sd <= 0) {
-			fprintf(stderr, "Trying to connect to evlnotifyd.\n");
-			if ((notify_sd = establishNfyConnection(&ns_sock)) > 0) {
+			(void) fprintf(stderr,
+				"%s: Trying to connect to evlnotifyd.\n",
+				ProgName);
+
+			notify_sd = establishNfyConnection(&ns_sock);
+			if (notify_sd > 0) {
 				FD_SET(notify_sd, &all_sds);
 				maxsd = MAX(notify_sd, maxsd);
-			} 
+			}
 			else {
 				tv.tv_sec = 2;
 				tv.tv_usec = 0;
@@ -647,7 +697,9 @@ run_parent(uid_t max_sysuid, int max_use
 				TRACE("got EINTR\n");
 				continue;
 			} else {
-				(void)fprintf(stderr, "evlogd: selection of specified file descriptors failed.\n");
+				(void) fprintf(stderr,
+		"%s: selection of specified file descriptors failed.\n",
+					ProgName);
 				perror("select");
 				if (errno != EBADF)
 					exit(1);
@@ -664,30 +716,27 @@ run_parent(uid_t max_sysuid, int max_use
 			clientinfo_t *cl, *empty;
 			char abyte;
 			int userconns, idx;
-			
+
 			if ((newsd = accept(listen_sd, NULL, NULL)) < 0) {
 				perror("accept");
 				goto exit_new_sd;
 			}
 			TRACE("Client is connecting.\n");	
-			if (getsockopt(newsd, SOL_SOCKET, SO_PEERCRED, &ucred, &ucredsz) < 0) {
+			if (getsockopt(newsd, SOL_SOCKET, SO_PEERCRED,
+						&ucred, &ucredsz) < 0) {
 				perror("getsockopt");
 			} else {
-				TRACE("uid = %d, pid = %d\n", ucred.uid, ucred.pid);
+				TRACE("uid = %d, pid = %d\n", ucred.uid,
+								ucred.pid);
 			} 
 
 			/* Record the pid of evlogrmtd */
-			if (rmtdpid == 0 && ucred.uid == 0) {
-				char *cmdline;
-				
-				if ((cmdline = getProcessCmd(ucred.pid)) != NULL) {
-					if (strstr(cmdline, "evlogrmtd")) {
-						rmtdpid = ucred.pid;
-					}
-					free(cmdline);
-				}
+			if ((rmtdpid == 0) && (ucred.uid == 0)) {
+				TRACE("evlogrmt pid cred check.\n");
+				evlogrmtCredCheck(ucred.pid);
+				TRACE("back from cred check.\n");
 			}
-				
+
 			/* Look for a free client slot; while doing
 			 * so we count the number of connections
 			 * per this uid, as well as recomputing the
@@ -709,15 +758,15 @@ run_parent(uid_t max_sysuid, int max_use
 			if (empty == NULL) {
 				TRACE("Max number of clients reached.\n");
 				close(newsd);
-				goto exit_new_sd;	
+				goto exit_new_sd;
 			}
 			/* Do not allow non-system users to
 			 * have too many connections open
 			 * simultaneously; otherwise they might
 			 * eat all our file descriptors and
 			 * disable logging entirely. */
-			if (ucred.uid > max_sysuid
-				&& userconns >= max_userconns) {
+			if (ucred.uid > max_sysuid &&
+						userconns >= max_userconns) {
 				TRACE("Too many simultaneous connections by uid %u\n", ucred.uid);
 				close(newsd);
 				goto exit_new_sd;
@@ -740,13 +789,15 @@ run_parent(uid_t max_sysuid, int max_use
 		if (notify_sd > 0 && FD_ISSET(notify_sd, &read_sds)) {
 			notify_sd = rmSocket(notify_sd);
 		}
-		
+
 		if (FD_ISSET(conf_sd, &read_sds)) {
 			/*
 			 * Accept the connection to the evlconfig command.
 			 */
 			if ((newsd = accept(conf_sd, NULL, NULL)) < 0){
-				(void)fprintf(stderr, "evlogd: canot accept connection to evlconfig\n");
+				(void) fprintf(stderr,
+			"%s: cannot accept connection to evlconfig\n",
+					ProgName);
 				perror("accept");
 				exit(1);
 			}
@@ -787,7 +838,8 @@ run_parent(uid_t max_sysuid, int max_use
 
 		/* TIMING */
 		gettimeofday(&perf_time_end, NULL);
-		timeval_subtract(&perf_time_temp, &perf_time_end, &perf_time_start);
+		timeval_subtract(&perf_time_temp, &perf_time_end,
+							&perf_time_start);
 		perf_time.tv_sec += perf_time_temp.tv_sec;
 		perf_time.tv_usec += perf_time_temp.tv_usec;
 		if (perf_time.tv_usec > 1000000) {
@@ -807,10 +859,19 @@ main(int argc, char **argv)
 	pid_t pid;
 	int bg = 1; /* Execute as a Daemon */
 	auto int c;
+	char *p;
 	uid_t max_sysuid = 99;
 	int max_userconns = 32;
 	int becnt;
-	
+
+	p = strrchr(argv[0], '/');
+
+	if (p == (char *) NULL) {
+		ProgName = argv[0];
+	} else {
+		ProgName = p + 1;
+	}
+
 	while ((c = getopt(argc, argv, "fsum:x2k:p")) != EOF) {
 		switch (c) {
 		case 'f':
@@ -843,7 +904,7 @@ main(int argc, char **argv)
 	initClients();
 	initSharedMem();
 	if (_evlValidate_pid(PidFile)) {
-		fprintf(stderr, "evlogd: Already running.\n");
+		(void) fprintf(stderr, "%s: Already running.\n", ProgName);
 		exit(1);
 	}
 	if ( lookup_symbol ) {
@@ -868,7 +929,10 @@ main(int argc, char **argv)
 	becnt = be_init();
 
 	if (becnt <= 0 && defaultPosixLog == 0) {
-		fprintf(stderr, "ERROR:evlogd needs atleast one backend plug-in for it to operate.\n");
+		(void) fprintf(stderr,
+			"%s at least one backend plug-in is required.\n",
+			ProgName);
+
 		exit(1); 
 	}
 
@@ -887,7 +951,8 @@ main(int argc, char **argv)
 			/* This code executes in the parent process */
 			if (kpid < 0) {
 				(void) fprintf(stderr,
-				"evlogd: Failed to start child process!\n");
+					"%s: Failed to start child process!\n",
+					ProgName);
 			}
 			run_parent(max_sysuid, max_userconns);
  		}
@@ -902,8 +967,8 @@ main(int argc, char **argv)
  * FUNCTION	: getNextRecId
  *
  * PURPOSE	: Returns the next recid for either regular or private log 
- * 			  an odd recid for regular log and an even recid for private
- * 			  log.
+ * 			  an odd recid for regular log and an even recid
+ *			  for private log.
  *
  * ARGS		: Log type 0 = private log ; 1 = regular log
  *
@@ -940,7 +1005,7 @@ initClients()
  	int maxci = 0;
  	for (i=0; i < MAX_CLIENTS; i++) {
  		clients[i].sd = CLIENT_SLOT_AVAILABLE;
- 	}
+	}
 }
 
 /* Compute max client index */
@@ -1003,9 +1068,9 @@ closeClientSocket(clientinfo_t *ci)
 		maxsd--;
 	} else if (new_maxsd != 0) {
 		if (new_maxsd < notify_sd)
-            maxsd = notify_sd;
-        else
-            maxsd = new_maxsd;
+			maxsd = notify_sd;
+		else
+			maxsd = new_maxsd;
 	}
 	
 	TRACE("Done closeClientSocket: maxsd = %d\n", maxsd);
@@ -1025,8 +1090,8 @@ struct ppc64kern_log_entry {
 	pid_t                   log_pid;
 	pid_t                   log_pgrp;
 	unsigned int            log_flags;
-	unsigned long long       log_thread;
-	posix_log_procid_t log_processor;
+	unsigned long long	log_thread;
+	posix_log_procid_t	log_processor;
 	long long		log_time_tv_sec;
 	long long		log_time_tv_nsec;
 };
@@ -1079,9 +1144,11 @@ processKernelEvents(void)
 	rtc_is_local = isRTC_Local();	
 	
 	if ((sd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0){
-		(void)fprintf(stderr, "Cannot create socket.\n");
+		(void) fprintf(stderr, "%s: Cannot create socket.\n",
+			ProgName);
 		return;
 	}
+
 	memset(&evlsock, 0, sizeof(struct sockaddr_un));
 	evlsock.sun_family = PF_UNIX;
 	(void)strcpy(evlsock.sun_path, EVLOGD_EVTSERVER_SOCKET);
@@ -1090,13 +1157,16 @@ processKernelEvents(void)
 	while (retry < 5) {
 		if (connect(sd, (struct sockaddr *)&evlsock, sock_len) < 0) {
 			if (retry > 5) {
-				(void)fprintf(stderr, "Cannot connect to daemon.\n");
+				(void) fprintf(stderr,
+					"%s: Cannot connect to daemon.\n",
+					ProgName);
 				return;
 			}
 			
 			retry ++;
 			sleep(1);
-			TRACE("kernel thread cannot connect, retry=%d.\n", retry);
+			TRACE("kernel thread cannot connect, retry=%d.\n",
+								retry);
 		}
 		break;
 	}
@@ -1130,30 +1200,39 @@ processKernelEvents(void)
 				rhdr = &recheader;
 				varbuf = (char *)(bufp + rechdr_size);
 
-				/* Adjust timestamp to local time for kernel event */
+				/*
+				 * Adjust timestamp to local time for
+				 * kernel event
+				 */
 				if (rhdr->log_flags & EVL_INITIAL_BOOT_EVENT) {
 					int gotTimeStamp = 0;
 #ifdef _POSIX_TIMERS_1
-					if (clock_gettime(CLOCK_REALTIME, &(rhdr->log_time)) == 0) {
+					if (clock_gettime(CLOCK_REALTIME,
+						&(rhdr->log_time)) == 0) {
 						gotTimeStamp = 1;
-						rhdr->log_time.tv_sec -= info.uptime;
+						rhdr->log_time.tv_sec -=
+								info.uptime;
 					}
 #endif
 					if (!gotTimeStamp) {
-						/* time stamp this with system startup time */
-						rhdr->log_time.tv_sec = (long) time(0) - info.uptime;
+						/*
+						 * time stamp this with
+						 * system startup time
+						 */
+						rhdr->log_time.tv_sec =
+						(long) time(0) - info.uptime;
 						rhdr->log_time.tv_nsec = 0;
 					} 
 				}
 				else if ((rhdr->log_flags & EVL_KERNTIME_LOCAL) && (rtc_is_local == 1)) {
-					rhdr->log_time.tv_sec = rhdr->log_time.tv_sec + (tz.tz_minuteswest * 60) ;
+					rhdr->log_time.tv_sec = rhdr->log_time.tv_sec + (tz.tz_minuteswest * 60);
 				}
 				/* mask off the time relate flags - don't need them anymore*/
-				rhdr->log_flags &= 	~(EVL_INITIAL_BOOT_EVENT | EVL_KERNTIME_LOCAL);
+				rhdr->log_flags &= ~(EVL_INITIAL_BOOT_EVENT | EVL_KERNTIME_LOCAL);
 
 				if ((rhdr->log_flags & EVL_EVTYCRC) &&
-		    		    (rhdr->log_format == POSIX_LOG_STRING
-		    		    || rhdr->log_format == POSIX_LOG_PRINTF)) {
+		    		    (rhdr->log_format == POSIX_LOG_STRING ||
+					rhdr->log_format == POSIX_LOG_PRINTF)) {
 					/* event type = CRC of msg/fmt string */
 					rhdr->log_event_type =
 						evl_gen_event_type_v2(varbuf);
@@ -1161,11 +1240,12 @@ processKernelEvents(void)
 				
 				TRACE("Writing a kernel event\n");
 				
-				if ((ret = writeKernEvt(sd, rhdr, varbuf)) == EIO) {
-					close(sd);
+				ret = writeKernEvt(sd, rhdr, varbuf);
+				if (ret == EIO) {
+					(void) close(sd);
 					return;
 				}
-				
+
 				bufp += rlen ;
 				j -= rlen;
 			}
@@ -1198,7 +1278,7 @@ copyKernelHeader(const char *buf, struct
 
 	switch (k.log_kversion) {
 	case 1:
-	    {
+		{
 		struct kern_log_entry_v1 kentry;
 		memcpy(&kentry, buf, sizeof(kentry));
 		entry->log_magic = 0;
@@ -1221,10 +1301,10 @@ copyKernelHeader(const char *buf, struct
 		entry->log_processor =
 			(posix_log_procid_t) kentry.log_processor;
 		*hdr_size = sizeof(kentry);
+		}
 		break;
-	    }
 	case 2:
-	    {
+		{
 		struct kern_log_entry_v2 kentry;
 		memcpy(&kentry, buf, sizeof(kentry));
 		entry->log_magic = 0;
@@ -1247,12 +1327,11 @@ copyKernelHeader(const char *buf, struct
 		entry->log_processor =
 			(posix_log_procid_t) kentry.log_processor;
 		*hdr_size = sizeof(kentry);
-	    }
+		}
 	case 3:
-	    {
+		{
 		struct kern_log_entry_v3 kentry;
 		posix_log_facility_t facility;
-
 		memcpy(&kentry, buf, sizeof(kentry));
 		entry->log_magic = 0;
 		entry->log_recid = 0;
@@ -1276,14 +1355,14 @@ copyKernelHeader(const char *buf, struct
 		if (posix_log_strtofac(kentry.log_facility, &facility) != 0) {
 			/* Facility not registered.  Figure code=CRC of name. */
 			if (evl_gen_facility_code(kentry.log_facility,
-			    &facility) != 0) {
+							&facility) != 0) {
 				facility = LOG_KERN;
 			}
 		}
 		entry->log_facility = facility;
 		*hdr_size = sizeof(kentry);
+		}
 		break;
-	    }
 	default:
 		return -1;
 	}
@@ -1312,7 +1391,7 @@ getRecHeader(const char *buf, struct pos
 #ifdef _PPC_64KERN_32USER_
 	{
 		struct ppc64kern_log_entry ppc64_entry;
-		memcpy(&ppc64_entry, buf, sizeof(struct ppc64kern_log_entry)); 
+		memcpy(&ppc64_entry, buf, sizeof(struct ppc64kern_log_entry));
 
 		entry->log_magic = ppc64_entry.log_magic;
 		entry->log_recid = ppc64_entry.log_recid;
@@ -1378,13 +1457,14 @@ writeKernEvt(int sd, struct posix_log_en
 	sigsBlocked = (_evlBlockSignals(&oldset) == 0);
 
 #ifdef POSIX_LOG_TRUNCATE
-	if (entry->log_format == POSIX_LOG_STRING
-	    && (entry->log_flags & POSIX_LOG_TRUNCATE) != 0) {
-
+	if ((entry->log_format == POSIX_LOG_STRING) &&
+			(entry->log_flags & POSIX_LOG_TRUNCATE) != 0) {
 		/* First write the header */
 		if ((n = write(sd, entry, REC_HDR_SIZE)) != REC_HDR_SIZE) {
 			/* socket is broken */
-			fprintf(stderr, "Failed to write the msg header to evlog daemon.\n");
+			(void) fprintf(stderr,
+			"%s: msg header write failure to evlog daemon.\n",
+			ProgName);
 			ret = EIO;
 			goto err_exit;
 		}
@@ -1398,9 +1478,12 @@ writeKernEvt(int sd, struct posix_log_en
 		bcopy((void *)buf, (void *)writebuf, entry->log_size);
 		/* then write the variable message body */
 		writebuf[POSIX_LOG_ENTRY_MAXLEN - 1] = '\0';
-		if ((n = write(sd, writebuf, entry->log_size)) != entry->log_size) {
+		if ((n = write(sd, writebuf, entry->log_size)) !=
+							entry->log_size) {
 			/* socket is broken */
-			fprintf(stderr, "Failed to write the msg body to evlog daemon.\n");
+			(void) fprintf(stderr,
+				"%s: msg body write failure to evlog daemon.\n",
+				ProgName);
 			ret = EIO;
 			goto err_exit;
 		}
@@ -1432,63 +1515,65 @@ writeKernEvt(int sd, struct posix_log_en
 		goto write_without_resolve;
 
 	TRACE ("Try resolving the kernel addresses to symbols\n");
-	while ( *ptr && (ptr <= buf + entry->log_size) ) {
-		switch ( parse_state )
-			{
-			case PARSING_TEXT:
-				if ( *ptr == '[' )
-					parse_state = PARSING_SYMSTART;
-				break;
-			case PARSING_SYMSTART:
-				if ( *ptr == '<' ) {
-					parse_state = PARSING_SYMBOL;
-					sym_start = line;
-				} else
-					parse_state = PARSING_TEXT;
-				break;
-			case PARSING_SYMBOL:
-				if ( *ptr == '>' )
-					parse_state = PARSING_SYMEND;
-				else if ( *ptr < '0' ||
-						  *ptr > 'f' ||
-						  ((*ptr > '9') && (*ptr < 'A')) ||
-						  ((*ptr > 'F') && (*ptr < 'a'))
-						  )
-					parse_state = PARSING_TEXT;
+	while (*ptr && (ptr <= buf + entry->log_size)) {
+		switch (parse_state) {
+		case PARSING_TEXT:
+			if (*ptr == '[')
+				parse_state = PARSING_SYMSTART;
+			break;
+		case PARSING_SYMSTART:
+			if (*ptr == '<') {
+				parse_state = PARSING_SYMBOL;
+				sym_start = line;
+			}
+			else
+				parse_state = PARSING_TEXT;
+			break;
+		case PARSING_SYMBOL:
+			if (*ptr == '>')
+				parse_state = PARSING_SYMEND;
+			else if (*ptr < '0' || *ptr > 'f' ||
+					((*ptr > '9') && (*ptr < 'A')) ||
+					((*ptr > 'F') && (*ptr < 'a'))) {
+				parse_state = PARSING_TEXT;
+			}
+			break;
+		case PARSING_SYMEND:
+			if (*ptr != ']') {
+				parse_state = PARSING_TEXT;
 				break;
-			case PARSING_SYMEND:
-				if ( *ptr != ']' ) {
-					parse_state = PARSING_TEXT;
-					break;
-				}
-				*(line - 1) = '\0';
-				value = strtoul(sym_start + 1, NULL, 16);
-				*(line - 1) = '>';  /* put the '>' back */
-				if ( (symbol = LookupSymbol(value, &sym)) == NULL ) {
-					TRACE("Cannot find symbol for address [<%lx>]\n", value);
-					parse_state = PARSING_TEXT;
-					break;
-				}
-				TRACE("Find symbol [%s] for address [<%lx>]\n", symbol, value);
-				if ( entry->log_size + strlen (symbol) + 10 >
-					 POSIX_LOG_ENTRY_MAXLEN ){
-					/*
-					 * 10 is the approximate max length of the extra
-					 * space. If we don't have enough space for the
-					 * symbol, we do not convert it.
-					 */
-					parse_state = PARSING_TEXT;
-					break;
-				}
-				len = sprintf (sym_start, "%s+%d/%d",
-							   symbol, sym.offset, sym.size);
-				line = sym_start + len;
-				expanded = 1;
+			}
+			*(line - 1) = '\0';
+			value = strtoul(sym_start + 1, NULL, 16);
+			*(line - 1) = '>';  /* put the '>' back */
+			symbol = LookupSymbol(value, &sym);
+			if (symbol == NULL) {
+				TRACE("Cannot find symbol for address [<%lx>]\n", value);
 				parse_state = PARSING_TEXT;
 				break;
-			default:  /* Can't get here! */
+			}
+			TRACE("Find symbol [%s] for address [<%lx>]\n",
+							symbol, value);
+
+			if (entry->log_size + strlen (symbol) + 10 >
+				 		POSIX_LOG_ENTRY_MAXLEN) {
+				/*
+				 * 10 is the approximate max length of the extra
+				 * space. If we don't have enough space for the
+				 * symbol, we do not convert it.
+				 */
 				parse_state = PARSING_TEXT;
+				break;
 			}
+			len = sprintf(sym_start, "%s+%d/%d", symbol,
+						sym.offset, sym.size);
+			line = sym_start + len;
+			expanded = 1;
+			parse_state = PARSING_TEXT;
+			break;
+		default:  /* Can't get here! */
+			parse_state = PARSING_TEXT;
+		}
 		*line++ = *ptr++;
 	}
 	*line = '\0';
@@ -1502,13 +1587,17 @@ writeKernEvt(int sd, struct posix_log_en
 	entry->log_size = strlen (writebuf) + 1;
 	if ((n = write(sd, entry, REC_HDR_SIZE)) != REC_HDR_SIZE) {
 		/* socket is broken */
-		fprintf(stderr, "Failed to write the msg header to evlog daemon.\n");
+		(void) fprintf(stderr,
+				"%s: evlog daemon msg header write failure.\n",
+				ProgName);
 		ret = EIO;
 		goto err_exit;
 	}
 	if ((n = write(sd, writebuf, entry->log_size)) != entry->log_size) {
 		/* socket is broken */
-		fprintf(stderr, "Failed to write the msg body to evlog daemon.\n");
+		(void) fprintf(stderr,
+				"%s: evlog daemon msg body write failure.\n",
+				ProgName);
 		ret = EIO;
 		goto err_exit;
 	}
@@ -1521,7 +1610,9 @@ writeKernEvt(int sd, struct posix_log_en
 	/* First write the header */
 	if ((n = write(sd, entry, REC_HDR_SIZE)) != REC_HDR_SIZE) {
 		/* socket is broken */
-		fprintf(stderr, "Failed to write the msg header to evlog daemon.\n");
+		(void) fprintf(stderr,
+				"%s: evlog daemon msg header write failure.\n",
+				ProgName);
 		ret = EIO;
 		goto err_exit;
 	}
@@ -1531,7 +1622,9 @@ writeKernEvt(int sd, struct posix_log_en
 	/* then write the variable message body */
 	if ((n = write(sd, buf, entry->log_size)) != entry->log_size) {
 		/* socket is broken */
-		fprintf(stderr, "Failed to write the msg body to evlog daemon.\n");
+		(void) fprintf(stderr,
+				"%s: evlog daemon msg body write failure.\n",
+				ProgName);
 		ret = EIO;
 		goto err_exit;
 	}
@@ -1591,7 +1684,9 @@ createQuery(char *qexp)
 	 */
 	if (dis_query.qu_tree != NULL) {
 		if (posix_log_query_destroy(&dis_query) != 0) {
-			fprintf(stderr, "evlogd: posix_log_query_destroy Failed\n"); 
+			(void) fprintf(stderr,
+				"%s: posix_log_query_destroy Failed\n",
+				ProgName);
 			return -1;
 		}
 		dis_query.qu_tree = NULL;
@@ -1599,15 +1694,198 @@ createQuery(char *qexp)
 	if(!strcmp(qexp, "nofilter")) {
 		return 0;
 	}
-	if (posix_log_query_create(qexp, POSIX_LOG_PRPS_NOTIFY, &dis_query,
-							   errbuf, 80) != 0) {
-		fprintf(stderr, "evlogd: posix_log_query_create: %s\n", errbuf);
+
+	if (posix_log_query_create(qexp, POSIX_LOG_PRPS_NOTIFY,
+					&dis_query, errbuf, 80) != 0) {
+		(void) fprintf(stderr, "%s: posix_log_query_create: %s\n",
+					ProgName, errbuf);
+
 		return -1;
 	}
 
 	return 0;
 }
 
+static int
+create_new_log_file(char *id)
+{
+	struct tm		tm_stuff;
+	struct timezone		timezone;
+	struct timeval		curr_time;
+	posix_log_recid_t	save_gRecId;
+	log_info_t		new_evl_log;
+	log_info_t		new_pvt_log;
+	char			time_stamp[128];
+	char			work_path[PATH_MAX];
+
+	TRACE("%s: newlog ID string [%s]\n", ProgName, id);
+
+	/*
+	 * Sample the clock.
+	 */
+
+	if (gettimeofday(&curr_time, &timezone) == -1) {
+		(void) fprintf(stderr, "%s: newlog time sampling failed\n",
+								ProgName);
+
+		return errno;
+	}
+
+	/*
+	 * Convert the time sampling into usable data.
+	 */
+
+	TRACE("%s: clock samples [%lu %lu]\n", ProgName, curr_time.tv_sec,
+							curr_time.tv_usec);
+
+	(void) localtime_r(&curr_time.tv_sec, &tm_stuff);
+
+	/*
+	 * Build the timestamp.
+	 */
+
+	if (*id == '\0') {
+		(void) sprintf(time_stamp,
+			"__%4.4d_%02.2d%02.2d_%02.2d%02.2d%02.2d__%lu",
+			tm_stuff.tm_year + 1900,
+			tm_stuff.tm_mon + 1, tm_stuff.tm_mday,
+			tm_stuff.tm_hour, tm_stuff.tm_min, tm_stuff.tm_sec,
+			curr_time.tv_usec);
+	}
+	else {
+		(void) sprintf(time_stamp,
+			"_%s__%4.4d_%02.2d%02.2d_%02.2d%02.2d%02.2d__%lu",
+			id,
+			tm_stuff.tm_year + 1900,
+			tm_stuff.tm_mon + 1, tm_stuff.tm_mday,
+			tm_stuff.tm_hour, tm_stuff.tm_min, tm_stuff.tm_sec,
+			curr_time.tv_usec);
+	}
+
+	TRACE("%s: timestamp: [%s]\n", ProgName, time_stamp);
+
+	/*
+	 * Create and initialize the new log files. This will minimize
+	 * the (critical) context swap time later. For now don't worry
+	 * about the event IDs.
+	 */
+
+	TRACE("%s: create new log files\n", ProgName);
+
+	(void) memset(&new_evl_log, 0, sizeof(log_info_t));
+	(void) sprintf(work_path, "%s_XXXXXX", LOG_CURLOG_PATH);
+	(void) unlink(work_path);
+
+	if (openMaybeCreate(work_path, 0644, &new_evl_log) < 0) {
+		if (new_evl_log.fd >= 0) {
+			(void) flock(new_evl_log.fd, LOCK_UN);
+			(void) close(new_evl_log.fd);
+		}
+
+		return EINVAL;
+	}
+
+	(void) memset(&new_pvt_log, 0, sizeof(log_info_t));
+	(void) sprintf(work_path, "%s_XXXXXX", LOG_PRIVATE_PATH);
+	(void) unlink(work_path);
+
+        if (openMaybeCreate(work_path, 0600, &new_pvt_log) < 0) {
+		if (new_pvt_log.fd >= 0) {
+			(void) flock(new_pvt_log.fd, LOCK_UN);
+			(void) close(new_pvt_log.fd);
+		}
+
+		return EINVAL;
+	}
+
+	/*
+	 * Label the log files properly (see openLogFiles).
+	 */
+
+	new_evl_log.recId = 1;
+	new_pvt_log.recId = 0;
+
+	save_gRecId = gRecId;
+	gRecId = 0;
+
+	mk_evl_rec(&new_evl_log,  LOG_LOGMGMT, POSIX_LOG_MGMT_TIMEMARK,
+			LOG_NOTICE, "Switched log files at (%lu, %lu)",
+			curr_time.tv_sec, curr_time.tv_usec);
+
+	mk_evl_rec(&new_pvt_log,  LOG_LOGMGMT, POSIX_LOG_MGMT_TIMEMARK,
+			LOG_NOTICE, "Switched log files at (%lu, %lu)",
+			curr_time.tv_sec, curr_time.tv_usec);
+
+	(void) close(new_evl_log.fd);
+	(void) close(new_pvt_log.fd);
+
+	gRecId = save_gRecId;
+
+	/*
+	 * Create the last event message in the (soon to be) old log files.
+	 */
+
+	mk_evl_rec(&evl_log,  LOG_LOGMGMT, POSIX_LOG_MGMT_TIMEMARK,
+			LOG_NOTICE, "Switched log files at (%lu, %lu)",
+			curr_time.tv_sec, curr_time.tv_usec);
+
+	mk_evl_rec(&pvt_log,  LOG_LOGMGMT, POSIX_LOG_MGMT_TIMEMARK,
+			LOG_NOTICE, "Switched log files at (%lu, %lu)",
+			curr_time.tv_sec, curr_time.tv_usec);
+
+	/*
+	 * Rename the current log files while they are open. This will work
+	 * even if management is running.
+	 */
+
+	TRACE("%s: start renames\n", ProgName);
+
+	(void) sprintf(work_path, "%s%s", LOG_CURLOG_PATH, time_stamp);
+	(void) rename(LOG_CURLOG_PATH, work_path);
+
+	(void) sprintf(work_path, "%s%s", LOG_PRIVATE_PATH, time_stamp);
+	(void) rename(LOG_PRIVATE_PATH, work_path);
+
+ 	/*
+	 * Dump any extra duplicates and update record ID in the
+	 * log_header_t structure for both log files.
+	 */
+
+	dumpDuplicatesBuffer(&evl_log);
+	dumpDuplicatesBuffer(&pvt_log);
+
+	evl_log.map_hdr->last_recId = gRecId;
+	(void) munmap(evl_log.map_hdr, sizeof(log_header_t));
+	pvt_log.map_hdr->last_recId = gRecId;
+	(void) munmap(pvt_log.map_hdr, sizeof(log_header_t));
+
+	/*
+	 * Close the old log files.
+	 */
+
+	(void) close(evl_log.fd);
+	(void) close(pvt_log.fd);
+
+	/*
+	 * Rename the new log files so they become the current log files.
+	 */
+
+	(void) sprintf(work_path, "%s_XXXXXX", LOG_CURLOG_PATH);
+	(void) rename(work_path, LOG_CURLOG_PATH);
+	(void) sprintf(work_path, "%s_XXXXXX", LOG_PRIVATE_PATH);
+	(void) rename(work_path, LOG_PRIVATE_PATH);
+
+	TRACE("%s: end renames\n", ProgName);
+
+	/*
+	 * Reinitialize the logs - start using the new log files.
+	 */
+
+	openLogFiles();
+
+	return 0;
+}
+
 /*
  * Update evlogd config values. User sent these values through 'evlconfig'
  * command.
@@ -1633,7 +1911,8 @@ updateConfvalues(int confsd) 
 
 		if (read(confsd, (void *) &cmd, sizeof(int)) != sizeof(int)) {
 			(void) fprintf(stderr,
-				"evlogd: Configuration command read failed\n");
+				"%s: Configuration command read failed\n",
+				ProgName);
 
 			error = EIO;
 			break;
@@ -1648,7 +1927,8 @@ updateConfvalues(int confsd) 
 
 		if (read(confsd, (void *) &value, sizeof(int)) != sizeof(int)) {
 			fprintf(stderr, 
-				"evlogd: Configuration value read failed\n");
+				"%s: Configuration value read failed\n",
+				ProgName);
 
 			error = EIO;
 			break;
@@ -1666,7 +1946,8 @@ updateConfvalues(int confsd) 
 
 			if (read(confsd, (void *) &cbuf, value) != value) {
 				(void) fprintf(stderr,
-				"evlogd: Configuration string read failed\n");
+				"%s: Configuration string read failed\n",
+				ProgName);
 
 				error = EIO;
 				break;
@@ -1741,6 +2022,10 @@ updateConfvalues(int confsd) 
 			}
 
 			break;
+ 		case NEWLOG:
+ 			error = create_new_log_file(cbuf);
+ 			break;
+ 		}
 	}
 	while (error == 0);
 
@@ -1750,19 +2035,21 @@ updateConfvalues(int confsd) 
 
 	if (write(confsd, (void *) &error, sizeof(int)) != sizeof(int)) {
 		(void) fprintf(stderr,
-			"evlogd: Configuration status write failed\n");
+				"%s: Configuration status write failed\n",
+				ProgName);
 	}
 
 	return error;
 }
 
 static int
-createSocket(char *sockname, int *sd, socklen_t *sock_len, struct sockaddr_un *sa, 
-			 mode_t mode, int backlog)
+createSocket(char *sockname, int *sd, socklen_t *sock_len,
+		struct sockaddr_un *sa, mode_t mode, int backlog)
 {
-
 	if ((*sd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {
-		fprintf(stderr, "evlogd: cannot create socket for communication with event server.\n");
+		(void) fprintf(stderr,
+			"%s: cannot create socket for event server.\n",
+			ProgName);
 		perror("socket");
 		return -1;
 	}
@@ -1776,7 +2063,9 @@ createSocket(char *sockname, int *sd, so
 	 * Bind the socket to the known socket address.
 	 */
 	if (bind(*sd, (struct sockaddr *) sa, *sock_len) < 0) {
-		(void)fprintf(stderr, "evlogd: cannot bind to socket for communication with event server.\n");
+		(void) fprintf(stderr,
+				"%s: cannot bind to event server socket.\n",
+				ProgName);
 		perror("bind");
 		return -1;
 	}
@@ -1784,7 +2073,9 @@ createSocket(char *sockname, int *sd, so
 	(void)chmod(sockname, mode);
 	/* Number of connections allowed in backlog */
 	if (listen(*sd, backlog) < 0) {
-		(void)fprintf(stderr, "evlogd: listening to socket connection failed.\n");
+		(void) fprintf(stderr,
+			"%s: listening to socket connection failed.\n",
+			ProgName);
 		perror("listen");
 		return -1;
 	}
@@ -1802,13 +2093,13 @@ openMaybeCreate(const char *path, mode_t
 	st.st_size = 0;
 	if (stat64(path, &st) || !st.st_size) {
 		create_file = 1;
-	}	
+	}
 	if ((linfo->fd = open64(path, O_RDWR|O_CREAT, mode)) < 0) {
-		fprintf(stderr, "evlogd: Cannot open EVL Log file '%s': %s\n",
-				path, strerror(errno));
+		(void) fprintf(stderr,
+				"%s: Cannot open EVL Log file '%s': %s\n",
+				ProgName, path, strerror(errno));
 		return -1;
 	}
-	
 	(void)flock(linfo->fd, LOCK_EX);
 	if (create_file) {
 		memset(&log_hdr, 0, sizeof(log_header_t));
@@ -1818,19 +2109,21 @@ openMaybeCreate(const char *path, mode_t
 		/* 
 		 * Newly created.  Write the log header structure. 
 		 */
-		if (write(linfo->fd, &log_hdr, sizeof(log_header_t))
-			!= sizeof(log_header_t)) {
-			fprintf(stdout, 
-					"evlogd: Cannot write log_header_t structure: %s",
-					strerror(errno));
+		if (write(linfo->fd, &log_hdr, sizeof(log_header_t)) !=
+						sizeof(log_header_t)) {
+			(void) fprintf(stderr,
+				"%s: Cannot write log_header_t structure: %s",
+				ProgName, strerror(errno));
 			return -1;
 		}
 	}
 
 	linfo->map_hdr = (log_header_t *)mmap(NULL, sizeof(log_header_t),
 			PROT_WRITE|PROT_READ, MAP_SHARED, linfo->fd, 0);
+
 	if (linfo->map_hdr == (log_header_t *)-1) {
-		fprintf(stdout, "evlogd: mmap failed: %s", strerror(errno));
+		(void) fprintf(stderr, "%s: mmap failed: %s",
+				ProgName, strerror(errno));
 		return -1;
 	}
 
@@ -1839,9 +2132,10 @@ openMaybeCreate(const char *path, mode_t
 	 * records.
 	 */
 	if (lseek64(linfo->fd, (loff_t) 0, SEEK_END) == (loff_t)-1) {
-		mk_evl_rec(&evl_log,LOG_LOGMGMT, EVLOG_SEEK_LOG_FAILED, LOG_CRIT,
-				   "evlogd: Cannot seek to the end of EVL log file: %s",
-				   strerror(errno));
+		mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SEEK_LOG_FAILED,
+			LOG_CRIT,
+			"%s: Cannot seek to the end of EVL log file: %s",
+			ProgName, strerror(errno));
 		return -1;
 	}
 
@@ -1860,30 +2154,34 @@ openMaybeCreate(const char *path, mode_t
 		 */ 
 		if (lseek64(linfo->fd, -((loff_t) sizeof(int)),
 						SEEK_CUR) == (loff_t) -1) {
-			mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SEEK_LOG_FAILED, 
-					   LOG_CRIT,"evlogd: Cannot seek in the EVL log file: %s",
-					   strerror(errno));
+			mk_evl_rec(&evl_log, LOG_LOGMGMT,
+				EVLOG_SEEK_LOG_FAILED, LOG_CRIT,
+				"%s: Cannot seek in the EVL log file: %s",
+				ProgName, strerror(errno));
 			return -1;
 		}
 		if (read(linfo->fd, &recsize, sizeof(int)) != sizeof(int)) {
-			mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_READ_LOG_FAILED, LOG_CRIT,
-					   "evlogd: Cannot read from the EVL log file: %s",
-					   strerror(errno));
+			mk_evl_rec(&evl_log, LOG_LOGMGMT,
+				EVLOG_READ_LOG_FAILED, LOG_CRIT,
+				"%s: Cannot read from the EVL log file: %s",
+				ProgName, strerror(errno));
 			return -1;
 		}
 		recsize = recsize + sizeof(int);
 		if (lseek64(linfo->fd, -((loff_t) recsize), SEEK_CUR) ==
-							(loff_t)-1) {
-			mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_SEEK_LOG_FAILED, LOG_CRIT,
-					   "evlogd: Cannot seek in the EVL log file: %s",
-					   strerror(errno));
+							(loff_t) -1) {
+			mk_evl_rec(&evl_log, LOG_LOGMGMT,
+				EVLOG_SEEK_LOG_FAILED, LOG_CRIT,
+				"%s: Cannot seek in the EVL log file: %s",
+				ProgName, strerror(errno));
 			return -1;
 		}
-		if (read(linfo->fd, &rec_hdr, sizeof(struct posix_log_entry)) !=
-			sizeof(struct posix_log_entry)) {
-			mk_evl_rec(&evl_log, LOG_LOGMGMT, EVLOG_READ_LOG_FAILED, LOG_CRIT,
-					   "evlogd: Cannot read from the EVL log file: %s",
-					   strerror(errno));
+		if (read(linfo->fd, &rec_hdr,sizeof(struct posix_log_entry)) !=
+					sizeof(struct posix_log_entry)) {
+			mk_evl_rec(&evl_log, LOG_LOGMGMT,
+				EVLOG_READ_LOG_FAILED, LOG_CRIT,
+				"%s: Cannot read from the EVL log file: %s",
+				ProgName, strerror(errno));
 			return -1;
 		}
 
@@ -1909,7 +2207,8 @@ valid_integer(const char *s, int *value)
 
 	*value = (int)strtol(s, &end, 0);
 	if (end == s) {
-		fprintf(stderr, "evlogd: Invalid value in evlog.conf file\n");
+		(void) fprintf(stderr,
+			"%s: Invalid value in evlog.conf file\n", ProgName);
 		return -1;
 	}
 
@@ -1924,7 +2223,7 @@ readEvlogConfig()
 {
 	int conf_fd, ret, error = 0;
 	FILE *conf_f;
-	char line[MAX_EVL_LINE], query_exp[MAX_EVL_LINE];
+	char line[MAX_EVL_LINE];
 	char *qexp = (char *)query_exp;
 	char *s, *p, c;
 
@@ -1950,8 +2249,9 @@ readEvlogConfig()
 			continue;
 		}
 		if ((s = strchr(p, ':')) == NULL) {
-			fprintf(stderr,
-					"evlogd: '%s' file got corrupted\n", confPath);
+			(void) fprintf(stderr,
+					"%s: '%s' file got corrupted\n",
+					ProgName, confPath);
 			return -1;
 		}
 		*s++ = '\0';
@@ -1963,7 +2263,9 @@ readEvlogConfig()
 				dis_dup_recs = 0;
 			} else {
 				fprintf(stderr,
-						"evlogd: Invalid string for 'Discard Dups' in the evlog.conf file\n");
+					"%s: Invalid string for 'Discard Dups' in the evlog.conf file\n",
+					ProgName);
+
 				error = -1;
 				goto out;
 			}
@@ -1972,10 +2274,13 @@ readEvlogConfig()
 			if ((error = valid_integer(s, &dup_interval)) < 0) {
 				goto out;
 			}
+
 			if (dup_interval < 0 || 
 				dup_interval > MAX_DUP_INTERVAL) {
-				fprintf(stderr, 
-						"evlogd: Invalid Discard Interval.\n");
+				(void) fprintf(stderr,
+					"%ss: Invalid Discard Interval.\n",
+					ProgName);
+
 				goto out;
 			}
 			continue;
@@ -1983,9 +2288,11 @@ readEvlogConfig()
 			if ((error = valid_integer(s, &Dup_count)) < 0) {
 				goto out;
 			}
+
 			if (Dup_count < 0 || Dup_count > MAX_DUP_COUNT) {
-				fprintf(stderr, 
-						"evlogd: Invalid Discard Count\n");
+				(void) fprintf(stderr,
+					"%s: Invalid Discard Count\n",
+					ProgName);
 				goto out;
 			}
 			continue;
@@ -1993,9 +2300,13 @@ readEvlogConfig()
 			if ((error = valid_integer(s, &dup_array_size)) < 0) {
 				goto out;
 			}
-			if (dup_array_size < 0 || dup_array_size > MAX_DUP_ARRAY_SIZE) {
-				fprintf(stderr,
-						"evlogd: Invalid Lookback Size\n");
+
+			if (dup_array_size < 0 ||
+					dup_array_size > MAX_DUP_ARRAY_SIZE) {
+				(void) fprintf(stderr,
+						"%s: Invalid Lookback Size\n",
+						ProgName);
+
 				goto out;
 			}
 		} else if (!strncmp(p, "Event Screen", 12)) {
@@ -2012,15 +2323,19 @@ readEvlogConfig()
 			*qexp = '\0';
 			continue;
 		} else if (!strncmp(p, "Console display level", 21)) {	
-			if ((error = valid_integer(s, &console_sev_level)) < 0) {
+			error = valid_integer(s, &console_sev_level);
+			if (error < 0) {
 				goto out;
 			}
-			TRACE("Console display level = %d\n", console_sev_level);
+
+			TRACE("Console display level = %d\n",
+							console_sev_level);
 		}	
 	}
 
 	if (!Dup_count && !dup_interval && dis_dup_recs) {
-		fprintf(stderr, "evlogd: Invalid evlog.conf values\n");
+		(void) fprintf(stderr, "%s: Invalid evlog.conf values\n",
+					ProgName);
 		goto out;
 	}
 	/* 
@@ -2044,13 +2359,15 @@ readEvlogConfig()
 
 	if (console_sev_level == CONSOLE_OUTPUT_DISABLE) {
 		if (ksyslog(6, NULL, 0) != 0) {
-			fprintf(stderr, 
-					"evlogd: Fail to disable console display\n");
+			(void) fprintf(stderr,
+				"%s: Fail to disable console display\n",
+				ProgName);
 		}	
 	} else {
 		if (ksyslog(8, NULL, console_sev_level) != 0) {
-			fprintf(stderr, 
-					"evlogd: Fail to set console display level\n");
+			(void) fprintf(stderr,
+				"%s: Fail to set console display level\n",
+				ProgName);
 		}	
 	}
 	 
@@ -2068,20 +2385,20 @@ readEvlogConfig()
 	fclose(conf_f);	/* closes conf_fd */
 	return error;
 }
-			
-	
+
 /*
  * Compare two event records.
  * Return 0 if the records are not matched; 1 for otherwise.
  */
 static int
-compareEventRecords(char *crec,  /* Current Record */
-					char *prec	 /* Previous Record */)
+compareEventRecords(	char *crec,	/* Current Record */
+			char *prec	 /* Previous Record */ )
 {
 	int pos;
 	char *pdata, *cdata;
-	struct posix_log_entry *phdr = (struct posix_log_entry *)prec;
-	struct posix_log_entry *chdr = (struct posix_log_entry *)crec;
+
+	struct posix_log_entry *phdr = (struct posix_log_entry *) prec;
+	struct posix_log_entry *chdr = (struct posix_log_entry *) crec;
 
 	if (prec == (void *)NULL) {
 		/*
@@ -2089,42 +2406,21 @@ compareEventRecords(char *crec,  /* Curr
 		 */
 		return 0;
 	}
-	if (phdr->log_size != chdr->log_size) {
-		return 0;
-	}
-	if (phdr->log_event_type != chdr->log_event_type) {
-		return 0;
-	}
-	if (phdr->log_facility != chdr->log_facility) {
-		return 0;
-	}
-	if (phdr->log_severity != chdr->log_severity) {
-		return 0;
-	}	
-	if (phdr->log_pid  != chdr->log_pid) {
-		return 0;
-	}
-	if (phdr->log_uid != chdr->log_uid) {
-		return 0;
-	}
-	if (phdr->log_gid != chdr->log_gid) {
-		return 0;
-	}
-	if (phdr->log_pgrp != chdr->log_pgrp) {
-		return 0;
-	}
-	if (phdr->log_format != chdr->log_format) {
-		return 0;
-	}
-	if (phdr->log_flags != chdr->log_flags) {
-		return 0;
-	}
-	if (phdr->log_thread != chdr->log_thread) {
-		return 0;
-	}
-	if (phdr->log_processor != chdr->log_processor) {
+
+	if ((phdr->log_size != chdr->log_size) ||
+	    (phdr->log_event_type != chdr->log_event_type) ||
+	    (phdr->log_facility != chdr->log_facility) ||
+	    (phdr->log_severity != chdr->log_severity) ||
+	    (phdr->log_pid  != chdr->log_pid) ||
+	    (phdr->log_uid != chdr->log_uid) ||
+	    (phdr->log_gid != chdr->log_gid) ||
+	    (phdr->log_pgrp != chdr->log_pgrp) ||
+	    (phdr->log_format != chdr->log_format) ||
+	    (phdr->log_flags != chdr->log_flags) ||
+	    (phdr->log_thread != chdr->log_thread) ||
+	    (phdr->log_processor != chdr->log_processor))
 		return 0;
-	}
+
 	/* 
 	 * Both record headers are same. Now compare variable data.
 	 */
@@ -2135,7 +2431,6 @@ compareEventRecords(char *crec,  /* Curr
 
 	return 1;
 }
-	
 
 static int
 evlogdstopdaemon()
@@ -2207,12 +2502,13 @@ mk_evl_rec(log_info_t *linfo, posix_log_
 		   const char *format, ...)
 {
 	char evbuf[REC_HDR_SIZE + POSIX_LOG_ENTRY_MAXLEN];
-	struct posix_log_entry *rentry = (struct posix_log_entry *)(char *)evbuf;
+	struct posix_log_entry *rentry;
 	int gotTimeStamp = 0, len;
 	va_list args;
 
 	va_start(args, format);
-	len = vsnprintf((char *)(evbuf + REC_HDR_SIZE), POSIX_LOG_ENTRY_MAXLEN, format, args);
+	len = vsnprintf((char *)(evbuf + REC_HDR_SIZE),
+					POSIX_LOG_ENTRY_MAXLEN, format, args);
 	va_end(args);
 
 #ifdef _POSIX_TIMERS_1
@@ -2220,6 +2516,8 @@ mk_evl_rec(log_info_t *linfo, posix_log_
 		gotTimeStamp = 1;
 	}
 #endif
+	rentry = (struct posix_log_entry *)(char *)evbuf;
+
 	if (!gotTimeStamp) {
 		rentry->log_time.tv_sec = (long) time(0);
 		rentry->log_time.tv_nsec = 0;
@@ -2257,20 +2555,20 @@ mk_evl_rec(log_info_t *linfo, posix_log_
  */
 void
 writeDiscardEvent(log_info_t *linfo, posix_log_facility_t facNum,
-				  int eventType,	int count)
+						int eventType, int count)
 {
 	char *fname, facname[POSIX_LOG_MEMSTR_MAXLEN];
 	char event[POSIX_LOG_MEMSTR_MAXLEN + 255];
 
 	fname = _evlGetFacilityName(facNum, facname);
 	if (fname == NULL) {
-		snprintf(event, sizeof(event),
-				 "Discarded %d duplicate events, event_type = 0x%x, facility = %d",
-				 count, eventType, facNum);
+		(void) snprintf(event, sizeof(event),
+	"Discarded %d duplicate events, event_type = 0x%x, facility = %d",
+			count, eventType, facNum);
 	} else {
-		snprintf(event, sizeof(event), 
-				 "Discarded %d duplicate events, event_type = 0x%x, facility = %s",
-				 count, eventType, fname);
+		(void) snprintf(event, sizeof(event),
+	"Discarded %d duplicate events, event_type = 0x%x, facility = %s",
+			count, eventType, fname);
 	}
 
 	mk_evl_rec(linfo, LOG_LOGMGMT, 1, LOG_INFO, event);
@@ -2506,8 +2804,8 @@ handleFacRegEvent(struct posix_log_entry
 	int status;
 	int oldWaitForKids;
 
-	if (rhdr->log_facility != LOG_LOGMGMT
-	    || rhdr->log_event_type != EVLOG_REGISTER_FAC) {
+	if ((rhdr->log_facility != LOG_LOGMGMT) ||
+			(rhdr->log_event_type != EVLOG_REGISTER_FAC)) {
 		/* The usual case */
 		return;
 	}
@@ -2608,7 +2906,7 @@ struct rec_hdr_32 {
 	unsigned int		log_time_tv_nsec;
 	unsigned int            log_flags;
 	unsigned int		log_thread;
-	posix_log_procid_t log_processor;
+	posix_log_procid_t	log_processor;
 };
 /* Annotate record comes from 32 bit apps under x86_64 */ 
 #define LOGREC_ARCH_X86_32	0xf000
@@ -2630,16 +2928,16 @@ populateRecHdr(clientinfo_t *ci, struct 
 		return -1;
 	}
 	TRACE("client_arch = %x\n", client_arch);
-	if (daemon_arch == LOGREC_ARCH_X86_64 && 
-		client_arch == LOGREC_ARCH_I386) {
+	if ((daemon_arch == LOGREC_ARCH_X86_64) &&
+					(client_arch == LOGREC_ARCH_I386)) {
 		/* 
 		 * 32 bit app writes this record - the header size 
 		 * is different (smaller)
 		 */
 		tmp = (char *) &rhdr32;
 		tmp += log_magic_size;
-		nbytes = read(ci->sd, tmp,
-					  rec_hdr_32_size - log_magic_size);
+		nbytes = read(ci->sd, tmp, rec_hdr_32_size - log_magic_size);
+
 		if (nbytes != rec_hdr_32_size - log_magic_size) {
 			closeClientSocket(ci);
 			return -1;
@@ -2672,8 +2970,8 @@ populateRecHdr(clientinfo_t *ci, struct 
 		TRACE("REC_HDR_SIZE=%d\n", REC_HDR_SIZE);	
 		tmp = (char *) rhdr;
 		tmp += log_magic_size;
-		nbytes = read(ci->sd, tmp,
-					  REC_HDR_SIZE - log_magic_size);
+		nbytes = read(ci->sd, tmp, REC_HDR_SIZE - log_magic_size);
+
 		if (nbytes != REC_HDR_SIZE - log_magic_size) {
 			closeClientSocket(ci);
 			return -1;
@@ -2716,7 +3014,8 @@ Process_Event(clientinfo_t *ci)
 		}
 
 		if (eptr == (event_buffer_t *) NULL) {
-			(void) fprintf(stderr, "evlogd: no free lookback!\n");
+			(void) fprintf(stderr, "%s: no free lookback!\n",
+					ProgName);
 
 			exit(1);
                 }
@@ -2915,18 +3214,21 @@ int 
 log_dropped_evtcnt_msg(log_info_t *linfo, int numevt_dropped)
 {
 	char evbuf[REC_HDR_SIZE + POSIX_LOG_ENTRY_MAXLEN + sizeof(evlrecsize_t)];
-	struct posix_log_entry *rentry = (struct posix_log_entry *)(char *)evbuf;
+	struct posix_log_entry *rentry;
 	int gotTimeStamp = 0, len;
 	uint recsize;
 	
 	len = snprintf((char*)(evbuf + REC_HDR_SIZE), POSIX_LOG_ENTRY_MAXLEN, 
-				   "%d events dropped due to secondary user buffer overflow.\n", numevt_dropped);
+		"%d events dropped due to secondary user buffer overflow.\n",
+		numevt_dropped);
 	
 #ifdef _POSIX_TIMERS_1
 	if (clock_gettime(CLOCK_REALTIME, &(entry.log_time)) == 0) {
 		gotTimeStamp = 1;
 	}
 #endif
+	rentry = (struct posix_log_entry *)(char *)evbuf;
+
 	if (!gotTimeStamp) {
 		rentry->log_time.tv_sec = (long) time(0);
 		rentry->log_time.tv_nsec = 0;
@@ -2959,16 +3261,18 @@ log_dropped_evtcnt_msg(log_info_t *linfo
 	memcpy((void *)(evbuf + recsize), &recsize , sizeof(evlrecsize_t));
 
 	if (lseek64(linfo->fd, (loff_t) 0, SEEK_END) == (loff_t)-1) {
-		fprintf(stderr,
-				"evlogd: Cannot seek in the EVL logfile\n");
-		return(-1);
+		(void) fprintf(stderr,
+				"%s: Cannot seek in the EVL logfile\n",
+				ProgName);
+		return -1;
 	}
 		
-	if (write(linfo->fd, (void *)evbuf, recsize + sizeof(evlrecsize_t)) != (recsize + sizeof(evlrecsize_t))) {
-		fprintf(stdout,
-				"evlogd: Cannot write an EVL record to the log file: %s\n",
-				strerror(errno));
-		return(-1);
+	if (write(linfo->fd, (void *) evbuf, recsize + sizeof(evlrecsize_t)) !=
+					(recsize + sizeof(evlrecsize_t))) {
+		(void) fprintf(stdout,
+			"%s: Cannot write an EVL record to the log file: %s\n",
+			ProgName, strerror(errno));
+		return -1;
 	}
 
 	writeEvtToNfyDaemon(evbuf);
@@ -2996,20 +3300,23 @@ writeEvtToNfyDaemon(char * evlbuf)
 	TRACE("Notification for rec_id %d\n", rentry->log_recid);
 
 		
-	if (writeEx(notify_sd, evlbuf,REC_HDR_SIZE) 
-		<= 0)  {
-		fprintf(stdout, "Fail to write rec header to notification socket. "
-						"Connection maybe broken.\n");
+	if (writeEx(notify_sd, evlbuf, REC_HDR_SIZE) <= 0)  {
+		(void) fprintf(stdout,
+			"%s: notification socket rec header write failure.\n",
+			ProgName);
+
 		notify_sd = rmSocket(notify_sd);
 		return;
 	}
+
 	if (rentry->log_size <= 0)
 		return;	/* nothing to write - return */
 		
-	if (writeEx(notify_sd, evlbuf + REC_HDR_SIZE,
-				rentry->log_size) <= 0) {
-		fprintf(stdout, "Fail to write record to notification socket. "
-						"Connection maybe broken.\n");
+	if (writeEx(notify_sd, evlbuf + REC_HDR_SIZE, rentry->log_size) <= 0) {
+		(void) fprintf(stdout,
+			"%s: notification socket rec header write failure.\n",
+			ProgName);
+
 		/* 
 		 * Notification daemon may already exit - reset
 		 * notification socket descriptor
@@ -3043,7 +3350,6 @@ write_rec_to_buf(log_info_t *linfo, char
 		return -1;
 	}
 	if (tmpPtr_evlbuf->buf == NULL) {
-		
 		tmpPtr_evlbuf->buf = malloc(bufsize);
 		if (!tmpPtr_evlbuf->buf) {
 			perror("malloc failed.\n");
@@ -3052,11 +3358,13 @@ write_rec_to_buf(log_info_t *linfo, char
 		tmpPtr_evlbuf->watermark = tmpPtr_evlbuf->buf;
 		tmpPtr_evlbuf->dropped_evt = 0;
 	}
-	if ((tmpPtr_evlbuf->watermark + rlen) <= (tmpPtr_evlbuf->buf + bufsize)) {
+	if ((tmpPtr_evlbuf->watermark + rlen) <=
+					(tmpPtr_evlbuf->buf + bufsize)) {
 		/* still fit in the buffer */
 		memcpy(tmpPtr_evlbuf->watermark, rbuf, rlen);
 		tmpPtr_evlbuf->watermark += rlen;
-		TRACE("Total bytes used in buf = %d\n", tmpPtr_evlbuf->watermark - tmpPtr_evlbuf->buf); 
+		TRACE("Total bytes used in buf = %d\n",
+				tmpPtr_evlbuf->watermark - tmpPtr_evlbuf->buf);
 	} else {
 		/* keep track of how many dropped events */
 		tmpPtr_evlbuf->dropped_evt++;
@@ -3076,7 +3384,7 @@ drain_buf_to_log(log_info_t *linfo)
 	size_t rlen;
 	int i = 0;
 	userbuf_info_t * tmpPtr_evlbuf;
-	
+
 	if (linfo->fd == user_evlbuf.fd) {
 		tmpPtr_evlbuf = &user_evlbuf;
 	} else if ( linfo->fd == userpriv_evlbuf.fd) {
@@ -3088,34 +3396,20 @@ drain_buf_to_log(log_info_t *linfo)
 	assert(tmpPtr_evlbuf->buf != 0);
 	
 	TRACE("Drain buffer to log\n", i);
-#if 0
-	tmp = tmpPtr_evlbuf->buf;
-	while (tmp < tmpPtr_evlbuf->watermark) {
-		rlen = ((evl_buf_rec_t *)tmp)->rechdr.log_size + REC_HDR_SIZE + sizeof(evlrecsize_t);	
-		if (write(linfo->fd, (void *)tmp, rlen) != rlen) {
-			fprintf(stdout,
-					"evlogd: Cannot write an EVL record to the log file: %s\n",
-					strerror(errno));
-			return(-1);
-		}
-		i++;
-		tmp += rlen;	
-	}
-	TRACE("Drain %d records\n", i);
-#endif
 
 	if (lseek64(linfo->fd, (loff_t) 0, SEEK_END) == (loff_t)-1) {
-		fprintf(stderr,
-				"evlogd: Cannot seek in the EVL logfile\n");
-		return(-1);
+		(void) fprintf(stderr,
+				"%s: Cannot seek in the EVL logfile\n",
+				ProgName);
+		return -1;
 	}
 	
 	rlen = tmpPtr_evlbuf->watermark - tmpPtr_evlbuf->buf;
 	if (write(linfo->fd, (void *) tmpPtr_evlbuf->buf, rlen) != rlen) {
-		fprintf(stdout,
-				"evlogd: Cannot write an EVL records to the log file: %s\n",
-				strerror(errno));
-		return(-1);
+		(void) fprintf(stderr,
+			"%s: Cannot write an EVL records to the log file: %s\n",
+			ProgName, strerror(errno));
+		return -1;
 	}
 
 	/* 
@@ -3147,15 +3441,14 @@ drain_buf_to_log(log_info_t *linfo)
 int
 write_rec_to_log(log_info_t *linfo, char *rbuf, size_t rlen) 
 {
-	if (lock_routine(linfo->fd, F_SETLK64, F_WRLCK) == -1 )
-		{
-			/* Fail to get the lock */
-			TRACE("Failed to get the lock, write event to buffer instead.\n");
-			//if (errno == EAGAIN)	
-			write_rec_to_buf(linfo, rbuf, rlen);		
-		
-			return 0;
-		}
+	if (lock_routine(linfo->fd, F_SETLK64, F_WRLCK) == -1 ) {
+		/* Fail to get the lock */
+		TRACE("Failed to get the lock, write event to buffer instead.\n");
+		//if (errno == EAGAIN)
+		write_rec_to_buf(linfo, rbuf, rlen);
+
+		return 0;
+	}
 
 	/* If the userbuf has event(s) then drain it */
 	if (linfo->fd == user_evlbuf.fd && user_evlbuf.buf != NULL) {
@@ -3171,16 +3464,17 @@ write_rec_to_log(log_info_t *linfo, char
 	} 	
 
 	if (lseek64(linfo->fd, (loff_t) 0, SEEK_END) == (loff_t)-1) {
-		fprintf(stderr,
-				"evlogd: Cannot seek in the EVL logfile\n");
-		return(-1);
+		(void) fprintf(stderr,
+				"%s: Cannot seek in the EVL logfile\n",
+				ProgName);
+		return -1;
 	}
 	TRACE("Write event rec to log, rlen=%d\n", rlen);
 	if (write(linfo->fd, (void *)rbuf, rlen) != rlen) {
-		fprintf(stdout,
-				"evlogd: Cannot write an EVL record to the log file: %s\n",
-				strerror(errno));
-		return(-1);
+		(void) fprintf(stderr,
+			"%s: Cannot write an EVL record to the log file: %s\n",
+			ProgName, strerror(errno));
+		return -1;
 	}
 
 	lock_routine(linfo->fd, F_SETLK64, F_UNLCK);
@@ -3220,16 +3514,17 @@ log_evl_rec(log_info_t *linfo, char *rec
 		lock_routine(linfo->fd, F_SETLK64, F_UNLCK);
 		return -1;
 	}
+
 	if ((logrec->log_severity & (LOG_EMERG | LOG_CRIT | LOG_ALERT)) ||
 		logrec->log_facility == LOG_AUTHPRIV) {
 #ifdef _POSIX_SYNCHRONIZED_ID
 		fdatasync(linfo->fd);
 #endif
 	}
-	writeEvtToNfyDaemon(lbuf);	
+	writeEvtToNfyDaemon(lbuf);
 	return 0;
 }
-	
+
 static int
 rmSocket(int soc)
 {
@@ -3252,12 +3547,16 @@ int writeEx(int sd, void * buf, size_t l
 		n = write(sd, tmp, moreBytes);
 		if (n < 0) {
 			if(errno != EWOULDBLOCK) {
-				fprintf(stdout, "write error on sd %d\n", sd);
+				(void) fprintf(stderr,
+					"%s: write error on sd %d\n",
+					ProgName, sd);
 				return -1;
 			}
 		} else {
 			if (n == 0) {
-				fprintf(stdout, "Socket sd %d closed\n", sd);
+				(void) fprintf(stderr,
+					"%s: Socket sd %d closed\n",
+					ProgName, sd);
 				return -1;
 			}
 			moreBytes -= n;
@@ -3286,7 +3585,8 @@ int lock_routine(int fd, int cmd, int ty
 	struct flock64 lock;
 
 	lock.l_type = type;		/*F_RDLCK, F_WRLCK, or F_UNLOCK */
-	lock.l_len = lock.l_start = 0;	/* byte offset relative to lock.l_whence */
+	lock.l_len = 0;
+	lock.l_start = 0;
 	lock.l_whence = SEEK_SET;	/* or SEEK_CUR or SEEK_END*/
 
 	return( fcntl(fd, cmd, &lock) );
@@ -3544,46 +3844,22 @@ evl_callback(int cmd, const char * data1
 	case CB_UNLOAD_PLUGIN:
 	default:
 		/* Don't do anything */
-		fprintf(stderr, "Called back, but do nothing here.\n");
+		(void) fprintf(stderr,
+			"%s: Called back, but do nothing here.\n", ProgName);
 		break;
 	}
 	return 0;
 }
 
-char * 
-getProcessCmd(pid_t pid)
-{	
-	char buf[256 + 1];
-	char *cmd;
-	char path[40];
-	int fd;
-	size_t	r;
-
-	snprintf(path, sizeof(path), "/proc/%u/cmdline", pid);
-	if((fd = open(path, O_RDONLY)) == -1) {
-		return NULL;
-	}
-	
-	if (( r = read(fd, buf, 256)) != -1) {
-		buf[r] = '\0';
-	}
-
-	if((cmd = malloc(strlen(buf)+ 1)) == NULL) {
-		close(fd);
-		return NULL;
-	}
-	strcpy(cmd, buf);
-	close(fd);
-	return r == -1? NULL : cmd;
-}
-
 int
 establishNfyConnection(struct sockaddr *sa)
 {
 	int sd, retry=0;
 	size_t sock_len;
 	if ((sd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0){
-		(void)fprintf(stderr, "evlnotifyd: Server cannot create a connection to the evlogd daemon.\n");
+		(void) fprintf(stderr,
+			"%s evlnotifyd socket creation failure.\n",
+			ProgName);
 		return -1;
 	}
 	sa->sa_family = PF_UNIX;
@@ -3593,11 +3869,12 @@ establishNfyConnection(struct sockaddr *
 	while (connect(sd, sa, sock_len) < 0) {
 		retry++;
 		if (retry==5) {
-			fprintf(stderr, "evlogd: can't connect to notify daemon\n");
+			(void) fprintf(stderr,
+				"%s: can't connect to notify daemon\n",
+				ProgName);
 			close(sd);
 			return -1;
 		}
 	}
 	return sd;
 }
-	
Index: evlog-1.6.1/user/cmd/evlogmgr/evl_logmgmt.c
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogmgr/evl_logmgmt.c
+++ evlog-1.6.1/user/cmd/evlogmgr/evl_logmgmt.c
@@ -58,8 +58,6 @@
 
 #define LOGREC_MAGIC_HIWORD	(LOGREC_MAGIC & 0xffff0000)
 
-typedef enum set_gen { GEN_RESET, GEN_INCR, GEN_EVEN, GEN_ODD } set_gen_t;
-
 struct file_offset_info {
 	loff_t offset;
 	loff_t beginhole;
@@ -70,11 +68,11 @@ static char logmgmt_msg[128]="";
 static int g_num_delrec = 0;
 static loff_t reducedBytes = 0;
 static posix_log_query_t query;
-char error_str[256];
 static int logfd;
 static int g_backupCreated = 0;
 static loff_t sizeb4repair;
 extern int gzBackUpFlag;
+extern char *progName;
 
 /*
  * Valdiates the log record that is pointed at by offset.
@@ -100,7 +98,8 @@ validateRec(loff_t offset)
 		TRACE("lseek64 failed.\n");
 		return -1;
 	}
-	if (read(logfd, &recsize, sizeof(evlrecsize_t)) != sizeof(evlrecsize_t)) {
+	if (read(logfd, &recsize, sizeof(evlrecsize_t)) !=
+						sizeof(evlrecsize_t)) {
 		TRACE("read recsize at end of record failed.\n");
 		return -1;
 	}
@@ -117,7 +116,7 @@ validateRec(loff_t offset)
  * Returns the entire record size (including the evlrecsize at the end
  * of the record)
  */
-int
+static int
 getRecLen(const struct posix_log_entry *p_rhdr)
 {
 	if ((p_rhdr->log_magic & 0xffff0000) == LOGREC_MAGIC_HIWORD) {
@@ -131,20 +130,20 @@ getRecLen(const struct posix_log_entry *
  * Verify that record is matched the deletion query - also we don't want
  * to remove the mgmt message we wrote to the log. 
  */
-int
+static int
 doesRecMatchForDel(const struct posix_log_entry *p_rhdr, const char * varbuf)
 {
 	if (_evlEvaluateQuery(&query, p_rhdr, (char *) varbuf) &&
-				((strcmp((char *)logmgmt_msg, (char *) varbuf) != 0))) {
+		((strcmp((char *) logmgmt_msg, (char *) varbuf) != 0))) {
 		g_num_delrec++;
-		reducedBytes +=(REC_HDR_SIZE + p_rhdr->log_size + sizeof(evlrecsize_t));
+		reducedBytes += (REC_HDR_SIZE + p_rhdr->log_size +
+							sizeof(evlrecsize_t));
 		return 1;
 	}
 	return 0;
 }
 
-
-int 
+static int
 moveRecordUp(struct file_offset_info *fi, 
 			const struct posix_log_entry *rechdr, const char * buf)
 {
@@ -157,15 +156,15 @@ moveRecordUp(struct file_offset_info *fi
 			POSIX_LOG_ENTRY_MAXLEN);
 		return -1;
 	}
-	if (!buf) {
+	if (buf) {
+		varbuf = buf;
+	}
+	else {
 		if (read(logfd, &buff, remainder) != remainder) {
 			TRACE("Failed to read remainder of record to be moved.\n");
 			return -1;
 		}
 		varbuf = buff;
-	}
-	else {
-		varbuf = buf;
 	} 
 
 	if (lseek64(logfd, fi->beginhole, SEEK_SET) == (loff_t)-1) {
@@ -188,7 +187,9 @@ moveRecordUp(struct file_offset_info *fi
  * Walk the log and count records that match the query for deletion. 
  * Assume that the log file is opened and exclusively locked.
  */ 
-int countRecsForDeletion(posix_log_query_t *query, int * num_delrec, loff_t *delbytes)
+static int
+countRecsForDeletion(posix_log_query_t *query, int *num_delrec,
+							loff_t *delbytes)
 {
 	loff_t bytes_to_process;
 	size_t reclen;
@@ -213,31 +214,36 @@ int countRecsForDeletion(posix_log_query
 		if (lseek64(logfd, offset, SEEK_SET) == (loff_t) -1) {
 			return EIO;
 		}
+
 		if (read(logfd, &rechdr, REC_HDR_SIZE) != REC_HDR_SIZE) {
 			return EIO;
 		}
-		
-		if (rechdr.log_size > 0 && rechdr.log_size <= POSIX_LOG_ENTRY_MAXLEN) {
-			if(read(logfd, &varbuf, rechdr.log_size) != rechdr.log_size) {
-				return EIO;	
-			}
+
+		if (rechdr.log_size > 0 &&
+				rechdr.log_size <= POSIX_LOG_ENTRY_MAXLEN) {
+			if (read(logfd, &varbuf, rechdr.log_size) !=
+							rechdr.log_size)
+				return EIO;
 		} 
 
-		if(read(logfd, &evlrecsize, sizeof(evlrecsize_t)) != sizeof(evlrecsize_t)) {
-			return EIO;	
-		}	
+		if (read(logfd, &evlrecsize, sizeof(evlrecsize_t)) !=
+						sizeof(evlrecsize_t)) {
+			return EIO;
+		}
 
-		if (evlrecsize != (REC_HDR_SIZE + rechdr.log_size) )	{
+		if (evlrecsize != (REC_HDR_SIZE + rechdr.log_size)) {
 			TRACE("Something wrong! Record size does not compute.\n");
 			return EIO;
 		}
-		
+
 		if (_evlEvaluateQuery(query, &rechdr, (char *) varbuf) &&
-				((strlen(logmgmt_msg) == 0) || (strcmp((char *)logmgmt_msg, (char *) varbuf) != 0))) {
+			((strlen(logmgmt_msg) == 0) ||
+			(strcmp((char *)logmgmt_msg, (char *) varbuf) != 0))) {
 			/* count number of records that would be deleted */
 			delcnt++;		
-			nbytes +=(REC_HDR_SIZE + rechdr.log_size + sizeof(evlrecsize_t));
-		}	
+			nbytes += (REC_HDR_SIZE + rechdr.log_size +
+							sizeof(evlrecsize_t));
+		}
 		/*
 		 * Adjust offset so we can move file pointer forward
 		 * to the next record 
@@ -246,7 +252,8 @@ int countRecsForDeletion(posix_log_query
 		bytes_to_process -= (evlrecsize + sizeof(evlrecsize_t));
 		reccnt++;
 	}
-	fprintf(stdout, "Total number of records is %d.\n", reccnt);
+	(void) fprintf(stdout, "%s: Total number of records is %d.\n",
+							progName, reccnt);
 	*num_delrec = delcnt;
 	*delbytes = nbytes; 
 	return ret;
@@ -255,7 +262,8 @@ int countRecsForDeletion(posix_log_query
 /* 
  *  Assume that the log file is openned and locked -
  */
-int compactLog(const char *logfilepath, int flags)
+static int
+compactLog(const char *logfilepath, int flags)
 {
 	int ret = 0;
 	char varbuf[POSIX_LOG_ENTRY_MAXLEN + sizeof(evlrecsize_t)];
@@ -279,27 +287,37 @@ int compactLog(const char *logfilepath, 
 	g_num_delrec = 0;	
 	while (fi.bytes_to_process > 0) {
 #ifdef __CRASH_TEST__
-	static int crash_now = 0;
-	if (crash_now == 10) {
-		fprintf(stderr, "System crashed!\n");
-		exit(1);
-	}
-	crash_now++;
+		static int crash_now = 0;
+
+		if (crash_now == 10) {
+			(void) fprintf(stderr, "%s: System crashed!\n",
+								progName);
+			exit(1);
+		}
+		crash_now++;
 #endif	
 		(void) lseek64(logfd, fi.offset, SEEK_SET);
+
 		if (read(logfd, &rechdr, REC_HDR_SIZE) != REC_HDR_SIZE) {
-			fprintf(stderr, "Failed to read record header.\n");
+			(void) fprintf(stderr,
+					"%s: Failed to read record header.\n",
+					progName);
 			ret = EIO;
 			goto err_exit;
 		}
 		if ((reclen = getRecLen(&rechdr)) == -1) {
-			fprintf(stderr, "getRecLen failed! Log file is corrupted.\n");
+			(void) fprintf(stderr,
+			"%s: getRecLen failed! Log file is corrupted.\n",
+							progName);
 			ret = EIO;
 			goto err_exit;
 		}
-		if(read(logfd, &varbuf, rechdr.log_size + sizeof(evlrecsize_t)) != 
-			(rechdr.log_size+sizeof(evlrecsize_t))) {
-			fprintf(stderr, "Failed to read variable data portion.\n");
+		if (read(logfd, &varbuf,
+				rechdr.log_size + sizeof(evlrecsize_t)) !=
+				(rechdr.log_size + sizeof(evlrecsize_t))) {
+			(void) fprintf(stderr,
+				"%s: Failed to read variable data portion.\n",
+				progName);
 			ret = EIO;
 			goto err_exit;	
 		}
@@ -311,7 +329,9 @@ int compactLog(const char *logfilepath, 
 		else if (fi.beginhole != 0) {
 			/* Updates fi.beginhole */
 			if (moveRecordUp(&fi, &rechdr, varbuf) != 0) {
-				fprintf(stderr, "Log file is corrupted. Compaction aborted.\n");
+				(void) fprintf(stderr,
+			"%s: Log file is corrupted. Compaction aborted.\n",
+						progName);
 				ret = EIO;
 				goto err_exit;
 			}
@@ -326,7 +346,8 @@ int compactLog(const char *logfilepath, 
 	 */
 	if ((fi.beginhole > 0) &&
 			(ftruncate64(logfd, fi.beginhole) == (loff_t) -1)) {
-		fprintf(stderr, "Failed to truncate log file\n");
+		(void) fprintf(stderr, "%s: Failed to truncate log file\n",
+				progName);
 		return EBADF;
 	}
 err_exit:
@@ -337,28 +358,38 @@ err_exit:
  * Scans the log file looking for a valid record.
  * If found returns pointer to that record otherwise -1.
  */
-loff_t
+static loff_t
 searchForNextGoodRecord(loff_t offset)
 {
 	static struct posix_log_entry *entry = 0; 
 	unsigned int log_magic;
 	size_t log_size;
 	evlrecsize_t recsize;
-	static int log_size_offset = (char *) &entry->log_size - (char *) entry;
+	static int log_size_offset;
+
+	log_size_offset = (char *) &entry->log_size - (char *) entry;
 	
 	(void) lseek64(logfd, offset, SEEK_SET);
-	while(read(logfd, &log_magic, sizeof(log_magic)) /*!= -1*/ == sizeof(log_magic)) {
+
+	while (read(logfd, &log_magic, sizeof(log_magic)) ==
+							sizeof(log_magic)) {
 		if ((log_magic & 0xffff0000) == LOGREC_MAGIC_HIWORD) {
 			(void) lseek64(logfd, offset + log_size_offset,
 								SEEK_SET);
-			if (read(logfd, &log_size, sizeof(log_size)) != sizeof(log_size)) {
-				fprintf(stderr, "Fail to read the record header.\n");
+			if (read(logfd, &log_size, sizeof(log_size)) !=
+							sizeof(log_size)) {
+				(void) fprintf(stderr,
+				"%s: Failed to read the record header.\n",
+					progName);
 				return -1;
 			}
 			(void) lseek64(logfd, offset + log_size + REC_HDR_SIZE,
 								SEEK_SET);
-			if (read(logfd, &recsize, sizeof(evlrecsize_t)) != sizeof(evlrecsize_t)) {
-				fprintf(stderr,"read recsize at end of record failed\n");
+			if (read(logfd, &recsize, sizeof(evlrecsize_t)) !=
+							sizeof(evlrecsize_t)) {
+				(void) fprintf(stderr,
+				"%s: read recsize at end of record failed\n",
+					progName);
 				return -1;
 			}
 			if ((log_size + REC_HDR_SIZE) == recsize) {
@@ -379,7 +410,7 @@ searchForNextGoodRecord(loff_t offset)
 /*
  * Tries to repair a corrupted log file. 
  */
-int 
+static int
 repairLog(int * status)
 {
 	int ret = 0;
@@ -407,14 +438,18 @@ repair_again:
 							(loff_t) -1) {
 			*status = 1;
 			/* found the corrupted record */
-			fprintf(stdout, "Found a corrupted event record."
-					  " Trying to resync with next good record...\n");
+			(void) fprintf(stdout,
+				"%s: Found a corrupted event record."
+				" Trying to resync with next good record...\n",
+				progName);
 			fi.beginhole = fi.offset;
 			if ((nextRecOffset = searchForNextGoodRecord(fi.offset)) == -1) {
 				/* Can't find another good record */
 				break;
 			}
-			fprintf(stdout, "Found a good record after the bad block!\n");
+			(void) fprintf(stdout,
+			"%s: Found a good record after the bad block!\n",
+					progName);
 			fi.bytes_to_process -= (nextRecOffset - fi.offset);
 			fi.offset = nextRecOffset;
 			TRACE("beginhole = %d\n", fi.beginhole);
@@ -426,12 +461,17 @@ repair_again:
 			 */
 			while (fi.bytes_to_process > 0) {	
 				(void) lseek64(logfd, fi.offset, SEEK_SET);
-				if (read(logfd, &rechdr, REC_HDR_SIZE) != REC_HDR_SIZE) {
-					fprintf(stderr, "Failed to read record header.\n");
+				if (read(logfd, &rechdr, REC_HDR_SIZE) !=
+								REC_HDR_SIZE) {
+					(void) fprintf(stderr,
+					"%s: Failed to read record header.\n",
+						progName);
 					return EIO;
 				}	
 				if ((reclen  = getRecLen(&rechdr)) == -1) {
-					fprintf(stderr, "getRecLen failed.\n");
+					(void) fprintf(stderr,
+						"%s: getRecLen failed.\n",
+						progName);
 					goto repair_again;
 				}
 
@@ -451,76 +491,23 @@ repair_again:
 	}
 	if ((fi.beginhole > 0) &&
 			(ftruncate64(logfd, fi.beginhole) == (loff_t) -1)) {
-		fprintf(stderr, "Failed to truncate log file.\n");
+		(void) fprintf(stderr, "%s: Failed to truncate log file.\n",
+								progName);
 		return EBADF;
 	}
 
 	return ret;
 }
-	
-/* 
- * Change generation number. Type = RESET| INCR | EVEN | ODD
- * Assume that logfile is locked.
- */
-int
-setGenerationNumber(set_gen_t type)
-{
-	log_header_t log_hdr;
-	struct posix_log_entry rec_hdr;
-
-	/* Make sure that we are the beginning of the file */
-	if (lseek64(logfd, (loff_t) 0, SEEK_SET) == (loff_t)-1) {
-		return EBADF;
-	}
-	if (read(logfd, &log_hdr,  sizeof(log_header_t)) != sizeof(log_header_t)) {
-		return EBADF;
-	}	
-	if (log_hdr.log_magic != LOGFILE_MAGIC) {
-		return EBADF;
-	}
 
-	switch(type) {
-		case GEN_INCR:
-			/* Increase the generation number */
-			log_hdr.log_generation++;
-			break;
-		case GEN_RESET:
-			log_hdr.log_generation = 0;
-			break;
-		case GEN_EVEN:
-			if (log_hdr.log_generation % 2) { 
-				log_hdr.log_generation++;
-			}
-			break;
-		case GEN_ODD:
-			if (!(log_hdr.log_generation % 2)) {
-				log_hdr.log_generation++;
-			}
-			break;
-		default:
-			break;
-	}
-	TRACE("log_generation = %d\n", log_hdr.log_generation);
-	
-	if (lseek64(logfd, (loff_t) 0, SEEK_SET) == (loff_t)-1 ) {
-		return EBADF;
-	}
-	/* write log_generation back to logfile */
-	if (write(logfd, &log_hdr, sizeof(log_header_t)) != sizeof(log_header_t)) {
-		return EBADF;
-	}	
-	
-	return 0;
-}
-
-	
 /*
  * Creates a backup log file -
  * Returns 0 if success otherwise -1;
  */
-#define BUF_SIZE			8 * 1024
+
+#define BUF_SIZE		8 * 1024
 #define MAX_FILEPATH_SIZE	256
-int
+
+static int
 createBackUp(const char *path)
 {
 	int bkfd;
@@ -537,31 +524,36 @@ createBackUp(const char *path)
 	sigsBlocked = (_evlBlockSignals(&oldset) == 0);
 	g_backupCreated = 0;
 	
-	if (gzBackUpFlag) {
-		snprintf(backup_filepath, sizeof(backup_filepath), "%s.bak.gz", path);
-	}
-	else {
-		snprintf(backup_filepath, sizeof(backup_filepath), "%s.bak", path);
-	}
+	if (gzBackUpFlag)
+		(void) snprintf(backup_filepath, sizeof(backup_filepath),
+							"%s.bak.gz", path);
+	else
+		(void) snprintf(backup_filepath, sizeof(backup_filepath),
+							"%s.bak", path);
 
 	if ((bkfd = open64(backup_filepath, O_CREAT|O_RDWR|O_TRUNC,
 						S_IRUSR | S_IWUSR)) < 0) {
-		(void)fprintf(stderr, "Failed to create back up copy of the log.\n");
+		(void) fprintf(stderr,
+			"%s: Failed to create back up copy of the log.\n",
+			progName);
 		ret = -1;
 		goto err_exit;
 	}
 	if (gzBackUpFlag) {
 		if ((gzbk = gzdopen(bkfd, "wb")) == NULL) {
-			fprintf(stderr, "Failed to create compressed file handle.\n");
+			(void) fprintf(stderr,
+			"%s: Failed to create compressed file handle.\n",
+				progName);
 			ret = -1;
 			goto err_exit;
 		}
 	}
 
 	/* Copy the contents of the log file to the back up file */
-	while((nbytesRead = read(logfd, bytes, BUF_SIZE)) > 0) {	
+	while((nbytesRead = read(logfd, bytes, BUF_SIZE)) > 0) {
 		if (gzBackUpFlag) {
-			if ((n = gzwrite(gzbk, bytes, nbytesRead)) != nbytesRead) {
+			if ((n = gzwrite(gzbk, bytes, nbytesRead)) !=
+								nbytesRead) {
 				TRACE("Failed to write to back up log file\n");
 				gzclose(gzbk);
 				close(bkfd);
@@ -570,23 +562,24 @@ createBackUp(const char *path)
 			}	
 		}
 		else {
-			if((n = write(bkfd, bytes, nbytesRead)) != nbytesRead) {
+			if ((n = write(bkfd, bytes, nbytesRead)) !=
+								nbytesRead) {
 				TRACE("Failed to write to back up log file\n");
 				close(bkfd);
 		 		ret = -1;
 		 		goto err_exit;
-			}	
-		}	
+			}
+		}
 	}
 	if (gzBackUpFlag) gzclose(gzbk);
 	(void) close(bkfd);
 	g_backupCreated = 1;
-	
+
 err_exit:
 	if (sigsBlocked) {
 		_evlRestoreSignals(&oldset);
 	}
-	
+
 	TRACE("Backup log created.\n");
 	return ret;
 }
@@ -594,18 +587,21 @@ err_exit:
 /* 
  * Remove back up log
  */
-void 
+static void
 removeBackup(const char *path)
 {
 	char backup_filepath[MAX_FILEPATH_SIZE];
-	if (gzBackUpFlag) {
-		snprintf(backup_filepath, sizeof(backup_filepath), "%s.bak.gz", path);
-	}
-	else {
-		snprintf(backup_filepath, sizeof(backup_filepath), "%s.bak", path);
-	}
+
+	if (gzBackUpFlag)
+		(void) snprintf(backup_filepath, sizeof(backup_filepath),
+							"%s.bak.gz", path);
+	else
+		(void) snprintf(backup_filepath, sizeof(backup_filepath),
+							"%s.bak", path);
+
 	unlink(backup_filepath);
-}	
+}
+
 /*
  * Restoring the original log file by copying back the backup file
  * to the original.
@@ -621,45 +617,58 @@ restoreLogfileFromBackup(const char *pat
 	sigset_t oldset;
 	int sigsBlocked;
 	
-	if (gzBackUpFlag) {
-		snprintf(backup_filepath, sizeof(backup_filepath), "%s.bak.gz", path);
-	}
-	else {
-		snprintf(backup_filepath, sizeof(backup_filepath), "%s.bak", path);
-	}
+	if (gzBackUpFlag)
+		(void) snprintf(backup_filepath, sizeof(backup_filepath),
+							"%s.bak.gz", path);
+	else
+		(void) snprintf(backup_filepath, sizeof(backup_filepath),
+							"%s.bak", path);
+
 	/* Mask all signals so we don't get interrupted */
 	sigsBlocked = (_evlBlockSignals(&oldset) == 0);
-	fprintf(stderr, "Restoring original logfile...\n");
+	(void) fprintf(stderr, "%s: Restoring original logfile...\n",
+								progName);
 	
 	if (g_backupCreated) { 
 		if ((bkfd = open64(backup_filepath, O_RDONLY,
 						S_IRUSR | S_IWUSR)) < 0) {
-			(void)fprintf(stderr, "Can't back up log file to restore.\n");
+			(void) fprintf(stderr,
+				"%s: Can't back up log file to restore.\n",
+				progName);
 			ret = -1;
 			goto err_exit;
 		} 
+
 		if ((gzbk = gzdopen(bkfd, "wb")) == NULL) {
-			fprintf(stderr, "Failed to create compressed file handle.\n");
+			(void) fprintf(stderr,
+			"%s: Failed to create compressed file handle.\n",
+				progName);
 			ret = -1;
 			goto err_exit;
 		}
 	}
 	else {
-		(void)fprintf(stderr, "There is no back up log file or it was not completely created. Restore aborts.\n");
+		(void) fprintf(stderr,
+	"%s: There is no back up log file or it was not completely created."
+	" Restore aborts.\n", progName);
 		ret = -1;
 		goto err_exit;
 	}	
 
 	if (lseek64(logfd, (loff_t) 0, SEEK_SET) == (loff_t)-1) {
 		ret = -1;
-		fprintf(stderr, "Failed to seek to the beginning of the log.\n");
+		(void) fprintf(stderr,
+			"%s: Failed to seek to the beginning of the log.\n",
+			progName);
 		goto err_exit;
 	}
 	/* Copy the contents of the back up file to the original log file */
 	/* Use gzread for both compressed file or uncompressed file. It works */
 	while ((nbytesRead = gzread(gzbk, bytes, BUF_SIZE)) > 0) {	
-		if((n = write(logfd, bytes, nbytesRead)) != nbytesRead) {
-			fprintf(stderr, "Failed to restore original log file.\n");
+		if ((n = write(logfd, bytes, nbytesRead)) != nbytesRead) {
+			(void) fprintf(stderr,
+				"%s: Failed to restore original log file.\n",
+				progName);
 			gzclose(gzbk);
 			close(bkfd);
 			ret = -1;
@@ -669,7 +678,7 @@ restoreLogfileFromBackup(const char *pat
 	gzclose(gzbk);
 	close(bkfd);
 	unlink(backup_filepath);
-	fprintf(stderr, "Original log is restored.\n");
+	(void) fprintf(stderr, "%s: Original log is restored.\n", progName);
 err_exit:
 //	evl_file_unlock();
 //	close(logfd);
@@ -678,8 +687,8 @@ err_exit:
 	}
 	return ret;
 }
-				
-int 
+
+static int
 backupFileExists(const char *path)
 {
 	int fd;
@@ -697,6 +706,39 @@ backupFileExists(const char *path)
 	}
 }
 
+/*
+ * cmd is F_GETLK64 see if lock exists on a file descriptor fd,
+ * or F_SETLK64 set a lock on file descriptor fd,
+ * or F_SETLKW64, the blocking version of F_SETLK64.
+ * Process sleeps until lock can be obtained.
+ *
+ */
+static int
+file_lock(int fd, int cmd, int type)
+{
+	struct flock64 lock;
+
+	lock.l_type = type;		/* F_RDLCK, F_WRLCK, or F_UNLOCK */
+	lock.l_len = lock.l_start = 0;	/* byte offset l_whence relative */
+	lock.l_whence = SEEK_SET;	/* or SEEK_CUR or SEEK_END */
+
+	return fcntl(fd, cmd, &lock);
+}
+
+/*
+ * File locking routines
+ */
+static int
+evl_file_lock(void)
+{
+	return file_lock(logfd, F_SETLKW64, F_RDLCK | F_WRLCK);
+}
+
+static int
+evl_file_unlock(void)
+{
+	return file_lock(logfd, F_SETLKW64, F_UNLCK);
+}
 
 /*
  * Repair logfile. If succeeded return 0 also set the log generation number
@@ -709,113 +751,83 @@ evl_repair_log(const char *path)
 	struct stat64 st;
 	st.st_size = 0;
 
-	if (posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_STARTMAINT,
-						LOG_NOTICE, 0, "%s", "Log repair started.") != 0) {
-			if (errno != ENOENT && errno != ECONNREFUSED)
-				perror("posix_log_printf of STARTMAINT message");
-			return errno;
-	}
-
 	if ((logfd = open64(path, O_RDWR)) == -1) {
 		perror("open");
-		posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_ENDMAINT,
-						LOG_NOTICE, 0, "%s", "Log repair failed, could not open log file.");
 		return EBADF;
 	}
 
 	(void) evl_file_lock();
 
 	if ((ret = repairLog(&status)) == 0) {
-		if (setGenerationNumber(GEN_EVEN) != 0) {
-			fprintf(stderr, "evl_repair_log: Failed to increase log file generation number.\n");
-			posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_ENDMAINT,
-						LOG_NOTICE, 0, "%s", 
-						"Log repair finished but failed to change "
-						"the log generation number to an even value.");
-	
-			return EBADF;
-		}
 		(void) fstat64(logfd, &st);
 		(void) evl_file_unlock();
 		(void) close(logfd);
 		if (status == 0) {
-			fprintf(stdout, "Log repair finished. No problem found.\n");
-			posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_ENDMAINT,
-						LOG_NOTICE, 0, "%s", "Log repair finished. No problem found.");
+			(void) fprintf(stdout,
+				"%s: Log repair finished. No problem found.\n",
+				progName);
 		} else if (status == 1) {	
-			fprintf(stdout, "Log repair finished, problem fixed. "
-							" Discarded %u bytes.\n", sizeb4repair - st.st_size);
-			snprintf(logmgmt_msg, sizeof(logmgmt_msg), "Log repair finished, problem fixed. "
-								 "Discarded %u bytes.", sizeb4repair - st.st_size);
-			posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_ENDMAINT,
-						LOG_NOTICE, 0, "%s", logmgmt_msg);
+			(void) fprintf(stdout,
+				"%s: Log repair finished, problem fixed. "
+				" Discarded %u bytes.\n",
+				progName, sizeb4repair - st.st_size);
 		}
 	} 
 	else {
 		(void) evl_file_unlock();
 		(void) close(logfd);
-		fprintf(stdout, "Log repair failed, errno=%u!\n", ret);	
-		posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_ENDMAINT,
-						LOG_NOTICE, 0, "%s", "Log repair failed");
+		(void) fprintf(stdout, "%s: Log repair failed, errno = %u!\n",
+							progName, ret);
 	}
 	
 	return ret;
 }	
 
-/**************************************************************************************
+/******************************************************************************
  
 evl_compact_log() does the lion's share of log management...
 
 1. Create a query object from the filter expression provided by the user.
-2. Log a "start" event (defined in the POSIX standard as POSIX_LOG_MGMT_STARTMAINT).
+2. Log a "start" event (defined in the POSIX standard as
+   POSIX_LOG_MGMT_STARTMAINT).
 3. Lock the log file.
-4. Create a backup copy of the original log file.  Create a compressed backup copy
-   if the user has specified that option.
- * If there is insufficient space to create a backup, and the --force option is not
-   specified, the log file is unlocked and the command returns an error without any
-   changes to the log file.
- * If the --force option is specified, this function continues even if it is unable
-   to create a backup copy.
+4. Create a backup copy of the original log file.  Create a compressed
+   backup copy if the user has specified that option.
+ * If there is insufficient space to create a backup, and the --force
+   option is not specified, the log file is unlocked and the command
+   returns an error without any changes to the log file.
+ * If the --force option is specified, this function continues even if it
+   is unable to create a backup copy.
 5. Set the "generation number" in the header of the log file to an odd value.
-6. Perform compaction by moving unmarked records to fill the space occupied by the
-   records selected for deletion, and truncates the log file.  The sequential order
-   of events in the event log is maintained during this process and the record ids
-   of the remaining event records are left unchanged.
+6. Perform compaction by moving unmarked records to fill the space occupied
+   by the records selected for deletion, and truncates the log file. The
+   sequential order of events in the event log is maintained during this
+   process and the record IDs of the remaining event records are left unchanged.
 7. Set the "generation number" in the header of the log file to an even value.
 8. Unlock the log file.
 9. Delete the backup copy of the log file (if a backup was created in step 4).
 10. Destroy the query object created in step 1.
-11. Log an "end" event (defined in the POSIX standard as POSIX_LOG_MGMT_ENDMAINT).
+11. Log an "end" event (defined in the POSIX standard as
+    POSIX_LOG_MGMT_ENDMAINT).
 
-***************************************************************************************/
+******************************************************************************/
 
 int
 evl_compact_log(const char *path, const char *filter, int flags)
 {
 	int ret, num_delrec;
 	int backup = 0;
-	time_t t;
-	
-	
-	if(posix_log_query_create(filter, POSIX_LOG_PRPS_GENERAL,
-             &query, error_str, 256) != 0) {
-		fprintf(stderr, "ERROR: could not create query object! Error message: \n   %s.\n", error_str);
-		return EINVAL;
-	}
+	char error_str[256];
 
-	/* 
-	 * Log this message with the time stamp to them unique so that we can
-	 * identify it later then don't delete it.
-	 */
-	time(&t);
-	snprintf(logmgmt_msg, sizeof(logmgmt_msg), "Log compaction on %s starts at %s", path, ctime(&t));
+	if (posix_log_query_create(filter, POSIX_LOG_PRPS_GENERAL,
+					&query, error_str, 256) != 0) {
+		(void) fprintf(stderr,
+			"%s: could not create query object: \n   %s.\n",
+			progName, error_str);
 
-	if (posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_STARTMAINT,
-						LOG_NOTICE, 0, "%s", logmgmt_msg) != 0) {
-			if (errno != ENOENT && errno != ECONNREFUSED)
-				perror("posix_log_printf of STARTMAINT message");
-			return errno;
+		return EINVAL;
 	}
+
 	if ((logfd = open64(path, O_RDWR)) == -1) {
 		perror("open of event log to be compacted.");
 		return EBADF;
@@ -834,114 +846,75 @@ evl_compact_log(const char *path, const 
 			/* continue compaction */
 		} 
 		else {
-			fprintf(stderr, "evl_compact_log: Failed to create backup logfile\n");
+			(void) fprintf(stderr,
+			"%s: Failed to create backup logfile\n", progName);
 			ret = EBADF;
 			goto err_exit;
 		}
 	}
 	else {
 		/* Back up file created */
-		backup=1;
-	}
-
-	if (setGenerationNumber(GEN_ODD) != 0 ) {
-		fprintf(stderr, "evl_compact_log: Failed to change log file generation number.\n");
-		ret = EBADF;
-		goto err_exit;
+		backup = 1;
 	}
 
 	if ((ret = compactLog(path, flags)) != 0) {
-		fprintf(stderr, "evl_compact_log: Failed to compact log.\n");
+		(void) fprintf(stderr,
+			"%s: Failed to compact log.\n", progName);
 		goto err_exit;
 	}	
-	
+
+	(void) posix_log_query_destroy(&query);
+
 err_exit:	
-	if (setGenerationNumber(GEN_EVEN) != 0) {
-		fprintf(stderr, "evl_compact_log: Failed to increase log file generation number.\n");
-		ret = EBADF;
-	}	
 	(void) evl_file_unlock();
 	close(logfd);
 	if (backup) {
 		removeBackup(path);
 	}
-	posix_log_query_destroy(&query);
-	if (ret == 0) {
-		snprintf(logmgmt_msg, sizeof(logmgmt_msg),
-			"Log compaction on %s ended. %d events were removed.", path, g_num_delrec);		
-	} else {
-		snprintf(logmgmt_msg, sizeof(logmgmt_msg),
-			"Log compaction on %s ended. Operation failed with errno = %d.", path, ret);
-	}
-	posix_log_printf(LOG_LOGMGMT, POSIX_LOG_MGMT_ENDMAINT,
-						LOG_NOTICE, 0, "%s", logmgmt_msg);
 	return ret;
 }
 
 /*
- * Returns 0 if succeeded and the total number of records that match the query for deletion.
+ * Returns 0 if succeeded and the total number of records that match the
+ * query for deletion.
  * Note: This function does not mark records for deletion, just counts them.
  */
 int 
-evlGetNumDelRec(const char *path, const char *filter, int *num_delrec, loff_t *delBytes)
+evlGetNumDelRec(const char *path, const char *filter, int *num_delrec,
+							loff_t *delBytes)
 {
 	int ret = 0, delrecs = -1;
 	loff_t nbytes = 0;
+	char error_str[256];
 
-	if(posix_log_query_create(filter, POSIX_LOG_PRPS_GENERAL,
-             &query, error_str, 256) != 0) {
-		fprintf(stderr, "ERROR: could not create query object! Error message: \n   %s.\n", error_str);
+	if (posix_log_query_create(filter, POSIX_LOG_PRPS_GENERAL,
+						&query, error_str, 256) != 0) {
+		(void) fprintf(stderr,
+			"%s: could not create query object: \n   %s.\n",
+			progName, error_str);
 
 		return EINVAL;
 	}
-	
+
 	if ((logfd = open64(path, O_RDONLY)) == -1) {
+		(void) posix_log_query_destroy(&query);
 		perror("open");
 		return EBADF;
 	}
 
+	(void) evl_file_lock();
+
 	if ((ret = countRecsForDeletion(&query, &delrecs, &nbytes)) != 0 ) {
-		fprintf(stderr, "evlGetNumDelRec: Failed to count record for deletion.\n");
-		goto err_exit;
+		(void) fprintf(stderr,
+		"%s: Failed to count record for deletion.\n", progName);
 	}
 
-err_exit:
+	(void) evl_file_unlock();
 	(void) close(logfd);
-	posix_log_query_destroy(&query);
+	(void) posix_log_query_destroy(&query);
+
 	*num_delrec = delrecs;
 	*delBytes = nbytes;
-	return ret;
-}
-
-/*
- * File locking routines
- */
-int 
-evl_file_lock() 
-{
-	return file_lock(logfd, F_SETLKW64, F_RDLCK | F_WRLCK);
-}
-
-int 
-evl_file_unlock()
-{
-	return file_lock(logfd, F_SETLKW64, F_UNLCK);
-}
-/* 
- * cmd is F_GETLK64 see if lock exists on a file descriptor fd,
- * or F_SETLK64 set a lock on file descriptor fd,
- * or F_SETLKW64, the blocking version of F_SETLK64.
- * Process sleeps until lock can be obtained. 
- * 
- */
-int 
-file_lock(int fd, int cmd, int type)
-{
-	struct flock64 lock;
 
-	lock.l_type = type;		/*F_RDLCK, F_WRLCK, or F_UNLOCK */
-	lock.l_len = lock.l_start = 0;	/* byte offset relative to lock.l_whence */
-	lock.l_whence = SEEK_SET;	/* or SEEK_CUR or SEEK_END*/
-
-	return( fcntl(fd, cmd, &lock) );
+	return ret;
 }
Index: evlog-1.6.1/user/cmd/evlogmgr/evl_logmgmt.h
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogmgr/evl_logmgmt.h
+++ evlog-1.6.1/user/cmd/evlogmgr/evl_logmgmt.h
@@ -33,8 +33,6 @@ int evlGetNumDelRec(const char *path, co
 int evl_compact_log(const char *path, const char *filter, int flags);
 int evl_cont_compact_log(const char *path);   
 int evl_repair_log(const char *path);
-int restoreLogfileFromBackup(const char *path);
-int backupFileExists(const char *path);
 
 #endif
 
Index: evlog-1.6.1/user/cmd/evlogmgr/evlogmgr.c
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogmgr/evlogmgr.c
+++ evlog-1.6.1/user/cmd/evlogmgr/evlogmgr.c
@@ -57,15 +57,12 @@
 #define STRINGARG 	2
 #define INTARG 		3
 
-char *progName = 0;
-char *logfile;
+char *progName;
 /* String args */
 char *cfilterStr = NULL;
 char *showstat = NULL;
 char *logFilePath = NULL;
 
-
-int privFlag = 0;
 int forceFlag = 0;
 
 int repairFlag = 0;
@@ -83,7 +80,6 @@ struct argInfo {
 };
 
 struct argInfo argInfo[] = {
-	{ "--private",		"-p", 	&privFlag, 	BOOLARG, 	0},
 	{ "--force",		"-F", 	&forceFlag, 	BOOLARG, 	0},
 	{ "--show-status",	"-s", 	&showstat, 	STRINGARG, 	0},
 	{ "--compact",		"-c",	&cfilterStr,	STRINGARG,	0},
@@ -94,15 +90,13 @@ struct argInfo argInfo[] = {
 	{ NULL,			NULL,	NULL,		0,		0}
 };
 
-void usage()
+void
+usage(void)
 {
-	fprintf(stderr, "Usage:\n"
-				"evlogmgr  -c | --compact <filter> [-F | --force] [-C | compr-bak]\n"
-					"         [[-p | --private] | [-l | --log <logfilepath>]]\n"
-					"evlogmgr  -f | --fix\n" 
-					"         [[-p | --private] | [-l | --log <logfilepath>]]\n"
-					"evlogmgr  -s | --show-status <filter>\n"
-					"         [[-p | --private] | [-l | --log <logfilepath>]]\n");
+	(void) fprintf(stderr, "Usage:\n"
+		"evlogmgr  -c | --compact <filter> [-F | --force] [-C | compr-bak] -l | --log <logfilepath>\n"
+		"evlogmgr  -f | --fix -l | --log <logfilepath>\n"
+		"evlogmgr  -s | --show-status <filter> -l | --log <logfilepath>\\n");
 	exit(1);
 }
 
@@ -111,9 +105,9 @@ findArg(const char *argName)
 {
 	struct argInfo *ai;
 	for (ai = argInfo; ai->argName; ai++) {
-		if (!strcmp(argName, ai->argName) || !strcmp(argName, ai->shrtName)) {
+		if (!strcmp(argName, ai->argName) ||
+		    !strcmp(argName, ai->shrtName))
 			return ai;
-		}
 	}
 	return NULL;
 }
@@ -133,12 +127,14 @@ processArgs(int argc, char **argv)
 		char *arg = *argv;
 		ai = findArg(arg);
 		if (!ai) {
-			fprintf(stderr, "%s: Unknown option: %s\n", progName, arg);
+			(void) fprintf(stderr, "%s: Unknown option: %s\n",
+				progName, arg);
 			usage();
 		}
 
 		if (ai->argSeen) {
-			fprintf(stderr,"%s: Multiple %s options not supported\n",
+			(void) fprintf(stderr,
+				"%s: Multiple %s options not supported\n",
 				progName, arg);
 			exit(1);
 		}
@@ -152,7 +148,7 @@ processArgs(int argc, char **argv)
 			argv++;
 			arg = *argv;
 			if (!arg) {
-				fprintf(stderr,
+				(void) fprintf(stderr,
 					"%s: Missing value for %s option\n",
 					progName, ai->argName);
 				usage();
@@ -175,9 +171,10 @@ processArgs(int argc, char **argv)
     		case INTARG:
     		{
     			char *endChar = 0;
-    		    long val = strtol(arg, &endChar, 0);
+			long val = strtol(arg, &endChar, 0);
+
     			if (*endChar != '\0' || val == -1) {
-    				fprintf(stderr,
+    				(void) fprintf(stderr,
     					"%s: Illegal value for %s option\n",
     					progName, ai->argName);
     				usage();
@@ -186,7 +183,9 @@ processArgs(int argc, char **argv)
     		    break;
     		}
     		default:
-    			fprintf(stderr,"%s: Internal error handling %s option\n", progName, arg);
+    			(void) fprintf(stderr,
+				"%s: Internal error handling %s option\n",
+				progName, arg);
     			exit(2);
 		} /*end switch */
 	} /* end for */
@@ -195,7 +194,7 @@ processArgs(int argc, char **argv)
 void
 semanticError(const char *msg)
 {
-	fprintf(stderr, "%s: %s\n", progName, msg);
+	(void) fprintf(stderr, "%s: %s\n", progName, msg);
 	exit(1);
 }
 
@@ -208,7 +207,8 @@ badOptionCombo(const char *opt1, const c
 	assert(ai2 != NULL);
 	if (ai1->argSeen && ai2->argSeen) {
 		char msg[200];
-		snprintf(msg, sizeof(msg), "Cannot specify %s with %s.", opt1, opt2);
+		(void) snprintf(msg, sizeof(msg),
+				"Cannot specify %s with %s.", opt1, opt2);
 		semanticError(msg);
 	}
 }
@@ -221,8 +221,6 @@ badOptionCombo(const char *opt1, const c
 void
 checkSemantics()
 {
-	int status;
-
 	/*
 	 * If -help is specified, print the usage message.  It's an error
 	 * if any other options are specified with -help.
@@ -231,7 +229,8 @@ checkSemantics()
 		usage();
 		exit(somethingBesidesHelp ? 1 : 0);
 	}
-	else if (cfilterStr) {
+
+	if (cfilterStr) {
 		badOptionCombo("--compact", "--show-status");
 		badOptionCombo("--compact", "--fix");
 	}	
@@ -251,91 +250,114 @@ checkSemantics()
 void 
 processCommand()
 {
-	int num_delrec;
-	loff_t delbytes;
-	int flags = 0;
-	
-	if (logFilePath) {
-		logfile = logFilePath;
-	}
-	else if (privFlag) {
-		logfile = LOG_PRIVATE_PATH;
-	}
-	else {
-		logfile = LOG_CURLOG_PATH;
-	}
 	if (cfilterStr) {
+		int flags = 0;
+
 		if (forceFlag) {
 			flags |= EVL_FORCE_COMPACT;
 		}
-		evl_compact_log(logfile, cfilterStr, flags);
+
+		evl_compact_log(logFilePath, cfilterStr, flags);
 	}
 	else if (showstat) {
-		if (evlGetNumDelRec(logfile, showstat, &num_delrec, &delbytes) == 0) {
+		loff_t	delbytes;
+		int	num_delrec;
+
+		if (evlGetNumDelRec(logFilePath, showstat, &num_delrec,
+							&delbytes) == 0) {
 			float kbytes = delbytes/1024;
-			fprintf(stdout, "Number of records matching the filter is %d.\n"
-							"Log file size would be reduced by %2.2f kbytes.\n", 
+
+			(void) fprintf(stdout,
+			"Number of records matching the filter is %d.\n"
+			"Log file size would be reduced by %2.2f kbytes.\n",
 							 num_delrec, kbytes);	
 		}	
 	}
 	else if (repairFlag) {
-		evl_repair_log(logfile);
+		evl_repair_log(logFilePath);
 	}
 }
 
 void SIGTerm_handler()
 {
-	restoreLogfileFromBackup(logfile);
+	restoreLogfileFromBackup(logFilePath);
 	exit(1);
 }
 
 int
 main (int argc, char *argv[])
 {
+	char *p;
+
 	static struct sigaction SigAllAction; /* Signal handler to terminate gracefully */
 	static struct sigaction act;
-	void SIGTerm_handler();
-	
-	uid_t uid = getuid();
-	/* 
-	 * Only root is allowed to run this tool, we check it here and also 
-	 * install the binary with root permission only.
-	 */
-	if (uid != 0) {
-		fprintf(stderr, "Only root is allowed to execute this utility.\n");
-		exit(1);
+
+	p = strchr(argv[0], '/');
+
+	if (p == (char *) NULL) {
+		progName = argv[0];
 	}
+	else {
+		progName = p + 1;
+	}
+
 	/* Parse command line option */
-	if (argc < 2) {
+	if (argc < 3) {
 		usage();
 	}
 	
 	processArgs(argc, argv);
 	checkSemantics();
 
+	if (logFilePath == (char *) NULL) {
+		(void) fprintf(stderr, "%s: log file path is required\n");
+
+		exit(1);
+	}
+
+	if ((strcmp(logFilePath, LOG_PRIVATE_PATH) == 0) ||
+	    (strcmp(logFilePath, LOG_CURLOG_PATH) == 0)) {
+		(void) fprintf(stderr,
+			"%s: cannot perform management on active log files.\n");
+		exit(1);
+	}
+
 	/*
-	 * Create new signal handler for SIGTERM. This will remove dr_socket and
-	 * terminate gracefully.
+	 * Only root is allowed to run this tool, we check it here and also
+	 * install the binary with root permission only.
+	 */
+	if (getuid() != 0) {
+		(void) fprintf(stderr,
+			"%s: Only root is allowed to execute this utility.\n",
+			progName);
+
+		exit(1);
+	}
+
+	/*
+	 * Create new signal handler for SIGTERM. This will remove dr_socket
+	 * and terminate gracefully.
 	 */
 	(void)memset(&SigAllAction, 0, sizeof(struct sigaction));
 	SigAllAction.sa_handler = SIGTerm_handler;
 	SigAllAction.sa_flags = 0;
 
 	if (sigaction(SIGTERM, &SigAllAction, NULL) < 0){
-		fprintf(stderr,
-			"%s: WARNING - sigaction failed for SIGTERM.\n", argv[0]); 
+		(void) fprintf(stderr,
+			"%s: WARNING - sigaction failed for SIGTERM.\n",
+			progName);
 	}
 	if (sigaction(SIGINT, &SigAllAction, NULL) < 0){
-		fprintf(stderr,
-			"%s: WARNING - sigaction failed for new SIGINT.\n", argv[0]); 
+		(void) fprintf(stderr,
+			"%s: WARNING - sigaction failed for new SIGINT.\n",
+			progName);
 	}
 	if (sigaction(SIGHUP, &SigAllAction, NULL) < 0){
-		fprintf(stderr,
-			"%s: WARNING - sigaction failed for new SIGHUP.\n", argv[0]);
+		(void) fprintf(stderr,
+			"%s: WARNING - sigaction failed for new SIGHUP.\n",
+			progName);
 	}
 
 	processCommand();
 	return 0;
 } 
-
-
Index: evlog-1.6.1/user/cmd/evlogmgr/evlogmgr.cron
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogmgr/evlogmgr.cron
+++ /dev/null
@@ -1,5 +0,0 @@
-# Everyday at 2:00 am run evl log manager and remove records ithat are older than 30 days
-0 2 * * * root /sbin/evlogmgr -c 'age > "30d"'
-
-# Everyday  at 1:00 am run evl log manager and remove records with severity=DEBUG
-0 1 * * * root /sbin/evlogmgr -c "severity=DEBUG"
Index: evlog-1.6.1/user/cmd/evlogmgr/Makefile.am
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogmgr/Makefile.am
+++ evlog-1.6.1/user/cmd/evlogmgr/Makefile.am
@@ -6,7 +6,7 @@ include $(top_srcdir)/Makefile.rules
 DISTCLEANFILES += 
 MAINTAINERCLEANFILES += 
 
-EXTRA_DIST += evlogmgr.cron Makefile.mk
+EXTRA_DIST += Makefile.mk
 
 MOSTLYCLEANFILES += 
 
@@ -17,8 +17,5 @@ sbin_PROGRAMS := evlogmgr
 evlogmgr_SOURCES := evl_logmgmt.h evlogmgr.c evl_logmgmt.c
 evlogmgr_LDADD := ../../lib/.libs/libevl.a
 
-logcrondir := @CRONDIR@
-logcron_DATA := evlogmgr.cron
-
 SUBDIRS := . test
 
Index: evlog-1.6.1/user/cmd/evlogmgr/Makefile.in
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlogmgr/Makefile.in
+++ evlog-1.6.1/user/cmd/evlogmgr/Makefile.in
@@ -49,7 +49,7 @@ am__configure_deps = $(am__aclocal_m4_de
 mkinstalldirs = $(mkdir_p)
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
-am__installdirs = "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(logcrondir)"
+am__installdirs = "$(DESTDIR)$(sbindir)"
 sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(sbin_PROGRAMS)
 am_evlogmgr_OBJECTS = evlogmgr.$(OBJEXT) evl_logmgmt.$(OBJEXT)
@@ -76,8 +76,6 @@ RECURSIVE_TARGETS = all-recursive check-
 	install-recursive installcheck-recursive installdirs-recursive \
 	pdf-recursive ps-recursive uninstall-info-recursive \
 	uninstall-recursive
-logcronDATA_INSTALL = $(INSTALL_DATA)
-DATA = $(logcron_DATA)
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -207,14 +205,12 @@ target_alias = @target_alias@
 MAINTAINERCLEANFILES = Makefile.in 
 DISTCLEANFILES = \\\#*\\\# Makefile 
 MOSTLYCLEANFILES = *~ *.[aios] *.bak *.ci *.io 
-EXTRA_DIST = evlogmgr.cron Makefile.mk
+EXTRA_DIST = Makefile.mk
 
 # General compilation flags
 INCLUDES = -I$(top_srcdir)/user/include -I$(top_srcdir)/user/include/linux
 evlogmgr_SOURCES := evl_logmgmt.h evlogmgr.c evl_logmgmt.c
 evlogmgr_LDADD := ../../lib/.libs/libevl.a
-logcrondir := @CRONDIR@
-logcron_DATA := evlogmgr.cron
 SUBDIRS := . test
 all: all-recursive
 
@@ -322,23 +318,6 @@ clean-libtool:
 distclean-libtool:
 	-rm -f libtool
 uninstall-info-am:
-install-logcronDATA: $(logcron_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(logcrondir)" || $(mkdir_p) "$(DESTDIR)$(logcrondir)"
-	@list='$(logcron_DATA)'; for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  f="`echo $$p | sed -e 's|^.*/||'`"; \
-	  echo " $(logcronDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(logcrondir)/$$f'"; \
-	  $(logcronDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(logcrondir)/$$f"; \
-	done
-
-uninstall-logcronDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(logcron_DATA)'; for p in $$list; do \
-	  f="`echo $$p | sed -e 's|^.*/||'`"; \
-	  echo " rm -f '$(DESTDIR)$(logcrondir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(logcrondir)/$$f"; \
-	done
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -502,7 +481,7 @@ check: check-recursive
 all-am: Makefile $(PROGRAMS) $(DATA)
 installdirs: installdirs-recursive
 installdirs-am:
-	for dir in "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(logcrondir)"; do \
+	for dir in "$(DESTDIR)$(sbindir)" ; do \
 	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
 	done
 install: install-recursive
@@ -553,7 +532,7 @@ info: info-recursive
 
 info-am:
 
-install-data-am: install-logcronDATA
+install-data-am:
 
 install-exec-am: install-sbinPROGRAMS
 
@@ -581,8 +560,7 @@ ps: ps-recursive
 
 ps-am:
 
-uninstall-am: uninstall-info-am uninstall-logcronDATA \
-	uninstall-sbinPROGRAMS
+uninstall-am: uninstall-info-am uninstall-sbinPROGRAMS
 
 uninstall-info: uninstall-info-recursive
 
@@ -593,14 +571,14 @@ uninstall-info: uninstall-info-recursive
 	distclean-recursive distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
 	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-logcronDATA install-man \
+	install-info-am install-man \
 	install-sbinPROGRAMS install-strip installcheck \
 	installcheck-am installdirs installdirs-am maintainer-clean \
 	maintainer-clean-generic maintainer-clean-recursive \
 	mostlyclean mostlyclean-compile mostlyclean-generic \
 	mostlyclean-libtool mostlyclean-recursive pdf pdf-am ps ps-am \
 	tags tags-recursive uninstall uninstall-am uninstall-info-am \
-	uninstall-logcronDATA uninstall-sbinPROGRAMS
+	uninstall-sbinPROGRAMS
 
 
 # Generate pre-parsed CC code.
Index: evlog-1.6.1/user/cmd/evlview/evlview.c
===================================================================
--- evlog-1.6.1.orig/user/cmd/evlview/evlview.c
+++ evlog-1.6.1/user/cmd/evlview/evlview.c
@@ -40,6 +40,7 @@
 #define _LARGEFILE64_SOURCE
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -49,6 +50,7 @@
 #include <signal.h>
 #include <locale.h>
 #include <time.h>
+#include <linux/limits.h>
 
 #include "config.h"
 #include "posix_evlog.h"
@@ -64,16 +66,12 @@ extern char *getFormatFromString(char *s
 extern char *getFormatFromFile(const char *path);
 extern char *parseSeparator(char *sep);
 
-static void seekToEnd();
-static void awaitEndOfLogMaint();
-static void handleReadOrSeekFailure(int status, const char *operation,
-	int resyncAction);
-
-char *progName = 0;
+char *progName = NULL;
 
 /* String args */
 char *filterStr = NULL;
 char *logPath = NULL;
+char *multiPath = NULL;
 char *outPath = NULL;
 char *separator = NULL;
 char *specFmtPath = NULL;
@@ -91,6 +89,7 @@ int acceptNonStdAtts = 0;
 int formatWithoutTemplates = 0;
 int syslogFlag = 0;
 int nmeqvalFlag = 0;
+int Debug = 0;
 
 /* Integer args */
 int nTailRecs = -1;
@@ -109,10 +108,8 @@ int initialRecid = -1;
 int format = FMT_DEFAULT;
 
 posix_log_query_t query;
-posix_log_query_t nfyQuery;
 posix_log_query_t *filter = NULL;
-posix_log_query_t *nfyFilter = NULL;
-posix_logd_t logdesc;	/* Read from here */
+posix_logd_t logDesc;	/* Read from here */
 int outFd = 1;		/* Write to here */
 FILE *outFile = NULL;
 char *defaultSeparator = ", ";
@@ -128,51 +125,6 @@ int needTemplateForSpecialFormat = 0;
 char *fdbuf;	/* Formatted data goes here. */
 size_t fdbufLen = 0;
 
-/*
- * These counters are used with --new.  If nfyCount > writeCount, it means
- * some events of interest have arrived and we haven't written them out yet.
- */
-long nfyCount = 0;
-long writeCount = 0;
-
-/*
- * These guys are used to help in recovery from interruption by a
- * log-maintenance operation.  LMRESYNC_* specify where to put the read
- * pointer after recovering: start of log (BOF), end of log, or just
- * before or after the last record successfully copied.
- *
- */
-posix_log_recid_t lastRecordCopied = -1;
-int logGeneration = 0;
-int viewingActiveLog = 1;
-int registeredForEndMaintEvents = 0;
-#define LMRESYNC_START	1
-#define LMRESYNC_END	2
-#define LMRESYNC_BEFORELAST	3
-#define LMRESYNC_AFTERLAST	4
-
-/* Notification signal handler for --new */
-static void
-nfyHandler(int signo, siginfo_t *info, void *context)
-{
-	nfyCount++;
-}
-
-/* Notification signal handler for POSIX_LOG_MGMT_ENDMAINT events */
-static void
-endMaintHandler(int signo, siginfo_t *info, void *context)
-{
-	logGeneration++;
-}
-
-static void
-reportReadOrSeekFailure(int status, const char *operation)
-{
-	errno = status;
-	perror(operation);
-	exit(2);
-}
-
 /* Fuss for parsing command line */
 #define BOOLARG 1
 #define STRINGARG 2
@@ -188,13 +140,14 @@ struct argInfo {
 
 struct argInfo argInfo[] = {
 	{ "--templates","-b",	&acceptNonStdAtts,	BOOLARG,	0},
-	{ "--notemplates","-B",	&formatWithoutTemplates,	BOOLARG,	0},
+	{ "--notemplates","-B",	&formatWithoutTemplates,BOOLARG,	0},
 	{ "--compact",	"-c",	&compact,	BOOLARG,	0},
 	{ "--datefmt",	"-d",	&dateFmtStr,	STRINGARG,	0},
 	{ "--filter",	"-f",	&filterStr,	STRINGARG,	0},
 	{ "--formatfile","-F",	&specFmtPath,	STRINGARG,      0},
 	{ "--help",	"-h",	&helpFlag,	BOOLARG,	0},
 	{ "--log",	"-l",	&logPath,	STRINGARG,      0},
+	{ "--multi",	"-M",	&multiPath,	STRINGARG,	0},
 	{ "--syslog",	"-m",	&syslogFlag,	BOOLARG,	0},
 	{ "--new",	"-n",	&newFlag,	BOOLARG,	0},
 	{ "--newlines",	"-N",	&newlines,	INTARG,		0},
@@ -207,23 +160,25 @@ struct argInfo argInfo[] = {
 	{ "--formatstr","-S",	&specFmtStr,	STRINGARG,      0},
 	{ "--tail",	"-t",	&nTailRecs,	INTARG,		0},
 	{ "--timeout",	"-T",	&timeout,	INTARG,		0},
+	{ "--debug",	"-Z",	&Debug,		BOOLARG,	0},
 	{ NULL,		NULL,	NULL,		0,		0}
 };
 
 static void
 printUsage()
 {
-	fprintf(stderr,
+	(void) fprintf(stderr,
 "Usage:\n"
 "%s --help\n"
 " OR\n"
 "%s [input] [output] [-f | --filter filter]\n"
-"	[-b | --templates] [-B | --notemplates]\n"
+"	[-b | --templates] [-B | --notemplates]\n\n"
 "input (defaults to %s,\n"
 "or to %s with -p | --private):\n"
 "	[-n | --new] [-T | --timeout nsec] [-R | --recid n]\n"
 "	OR\n"
-"	[-l | --log srclogfile] [-t | --tail nrec] [-r | --reverse]\n"
+"	[-l | --log srclogfile] OR [-M | --multi multi-file]\n"
+"	[-t | --tail nrec] [-r | --reverse]\n\n"
 "output (defaults to stdout):\n"
 "	[-o | --out destlogfile]\n"
 "	OR\n"
@@ -233,7 +188,7 @@ printUsage()
 "	OR\n"
 "	[-c | --compact] [-s | --separator sep] [-q | --nmeqval] [format_opts]\n"
 "	OR\n"
-"	[-m | --syslog]\n"
+"	[-m | --syslog]\n\n"
 "format_opts:\n"
 "	[-N | --newlines n] [-d | --datefmt date-format]\n",
 		progName, progName, LOG_CURLOG_PATH, LOG_PRIVATE_PATH);
@@ -251,7 +206,8 @@ findArg(const char *argName)
 {
 	struct argInfo *ai;
 	for (ai = argInfo; ai->argName; ai++) {
-		if (!strcmp(argName, ai->argName) || !strcmp(argName, ai->shrtName)) {
+		if (!strcmp(argName, ai->argName) ||
+				!strcmp(argName, ai->shrtName)) {
 			return ai;
 		}
 	}
@@ -270,15 +226,15 @@ processArgs(int argc, char **argv)
 
 	for (++argv; *argv; ++argv) {
 		char *arg = *argv;
+
 		ai = findArg(arg);
 		if (!ai) {
-			fprintf(stderr, "%s: Unknown option: %s\n", progName,
-				arg);
+			(void) fprintf(stderr, "%s: Unknown option: %s\n",								progName, arg);
 			usage();
 		}
 
 		if (ai->argSeen) {
-			fprintf(stderr,
+			(void) fprintf(stderr,
 				"%s: Multiple %s options not supported\n",
 				progName, arg);
 			exit(1);
@@ -293,7 +249,7 @@ processArgs(int argc, char **argv)
 			argv++;
 			arg = *argv;
 			if (!arg) {
-				fprintf(stderr,
+				(void) fprintf(stderr,
 					"%s: Missing value for %s option\n",
 					progName, ai->argName);
 				usage();
@@ -312,7 +268,7 @@ processArgs(int argc, char **argv)
 			char *endChar = 0;
 		    	long val = strtol(arg, &endChar, 0);
 			if (*endChar != '\0' || val == -1) {
-				fprintf(stderr,
+				(void) fprintf(stderr,
 					"%s: Illegal value for %s option\n",
 					progName, ai->argName);
 				usage();
@@ -321,7 +277,7 @@ processArgs(int argc, char **argv)
 		    	break;
 		    }
 		default:
-			fprintf(stderr,
+			(void) fprintf(stderr,
 				"%s: Internal error handling %s option\n",
 				progName, arg);
 			exit(2);
@@ -345,7 +301,10 @@ badOptionCombo(const char *opt1, const c
 	assert(ai2 != NULL);
 	if (ai1->argSeen && ai2->argSeen) {
 		char msg[200];
-		snprintf(msg, sizeof(msg), "Cannot specify %s with %s.", opt1, opt2);
+
+		(void) snprintf(msg, sizeof(msg),
+				"Cannot specify %s with %s.", opt1, opt2);
+
 		semanticError(msg);
 	}
 }
@@ -363,81 +322,28 @@ doWeNeedTemplateForSpecialFormat()
 {
 	evl_listnode_t *head, *end, *p;
 
-	if (formatWithoutTemplates) {
-		return;
-	}
-	head = parsedSpecialFmt;
-	for (p=head, end=NULL; p!=end; end=head, p=p->li_next) {
-		evl_fmt_segment_t *fs = (evl_fmt_segment_t*) p->li_data;
-		if (fs->fs_type == EVL_FS_ATTNAME
-		    || (fs->fs_type == EVL_FS_MEMBER
-		    && fs->u2.fs_member == POSIX_LOG_ENTRY_DATA)) {
-			needTemplateForSpecialFormat = 1;
-			break;
-		}
-	}
-}
-
-/*
- * Register to be notified about end-maintenance events.  Such an event
- * signals that the log is once again ready to be opened and read.
- *
- * If we succeed, set registeredForEndMaintEvents=1 and return 0.
- * If the notification daemon is unavailable, return -1.
- * Else print an error message and exit.
- */
-static int
-registerForEndMaintEvents()
-{
-	static struct sigevent endMaint;
-	static struct sigaction endMaintAction;
-	posix_log_query_t endMaintFilter;
-	char endMaintFilterExpr[100];
-	int status;
-	int ret;
-
-	snprintf(endMaintFilterExpr, sizeof(endMaintFilterExpr),
-		"facility=logmgmt && event_type=%d",
-		POSIX_LOG_MGMT_ENDMAINT);
-	status = posix_log_query_create(endMaintFilterExpr,
-		POSIX_LOG_PRPS_NOTIFY, &endMaintFilter, NULL, 0);
-	if (status != 0) {
-		fprintf(stderr, "%s: internal error: ", progName);
-		errno = status;
-		perror("posix_log_query_create for log-maintenance events");
-		exit(2);
-	}
+	if (!formatWithoutTemplates) {
+		head = parsedSpecialFmt;
 
-	(void) memset(&endMaintAction, 0, sizeof(endMaintAction));
-	endMaintAction.sa_sigaction = endMaintHandler;
-	endMaintAction.sa_flags = SA_SIGINFO;
-	if (sigaction(SIGRTMIN+2, &endMaintAction, NULL) < 0) {
-		fprintf(stderr, "%s: internal error: ", progName);
-		perror("sigaction for notification re: log-maintenance events");
-		exit(2);
-	}
-
-	endMaint.sigev_notify = SIGEV_SIGNAL;
-	endMaint.sigev_signo = SIGRTMIN+2;
-	endMaint.sigev_value.sival_int = 0;	/* not used */
-	status = posix_log_notify_add(&endMaintFilter, &endMaint,
-		POSIX_LOG_SEND_SIGVAL, NULL);
-	if (status == 0) {
-		registeredForEndMaintEvents = 1;
-		ret = 0;
-	} else if (status == EAGAIN) {
-		ret = -1;
-	} else {
-		fprintf(stderr, "%s: internal error: ", progName);
-		errno = status;
-		perror("posix_log_notify_add for log-maintenance events");
-		exit(2);
+		for (p = head, end = NULL; p != end;
+						end = head, p = p->li_next) {
+			evl_fmt_segment_t *fs =
+					(evl_fmt_segment_t*) p->li_data;
+
+			if (fs->fs_type == EVL_FS_ATTNAME ||
+				(fs->fs_type == EVL_FS_MEMBER &&
+				fs->u2.fs_member == POSIX_LOG_ENTRY_DATA)) {
+				needTemplateForSpecialFormat = 1;
+				break;
+			}
+		}
 	}
 
-	(void) posix_log_query_destroy(&endMaintFilter);
-	return ret;
+	return;
 }
 
+int viewingActiveLog;
+
 /*
  * The command line has been parsed.  Verify that the selected combination
  * of options, and the values of those options, make sense.  We finish most
@@ -446,8 +352,6 @@ registerForEndMaintEvents()
 static void
 checkSemantics()
 {
-	int status;
-
 	/*
 	 * If -help is specified, print the usage message.  It's an error
 	 * if any other options are specified with -help.
@@ -457,16 +361,39 @@ checkSemantics()
 		exit(somethingBesidesHelp ? 1 : 0);
 	}
 
-	if (private) {
-		badOptionCombo("--log", "--private");
-		logPath = LOG_PRIVATE_PATH;
-	}
+	/*
+	 * Handle the log file specification options.
+	 */
+
+	badOptionCombo("--log", "--multi");
+
+	if (multiPath == (char *) NULL) {
+		if (private) {
+			badOptionCombo("--log", "--private");
+
+			logPath = LOG_PRIVATE_PATH;
+		} else {
+			if (!logPath) {
+				logPath = LOG_CURLOG_PATH;
+			}
+		}
+
+		/* We know of only two logs that could be active... */
+		if ((strcmp(logPath, LOG_PRIVATE_PATH) != 0) &&
+		    (strcmp(logPath, LOG_CURLOG_PATH) != 0)) {
+			viewingActiveLog = 0;
+		}
+		else {
+			viewingActiveLog = 1;
+		}
+	} else {
+		badOptionCombo("--multi", "--new");
+		badOptionCombo("--multi", "--tail");
+		badOptionCombo("--multi", "--recid");
+		badOptionCombo("--multi", "--private");
+		badOptionCombo("--multi", "--timeout");
+		badOptionCombo("--multi", "--reverse");
 
-	/* We know of only two logs that could be active... */
-	viewingActiveLog = 1;
-	if (logPath
-	    && strcmp(logPath, LOG_PRIVATE_PATH) != 0
-	    && strcmp(logPath, LOG_CURLOG_PATH) != 0) {
 		viewingActiveLog = 0;
 	}
 
@@ -533,7 +460,8 @@ checkSemantics()
 			/* Parse string into segments later. */
 		}
 		if (newlines == 0 || newlines < -1) {
-			semanticError("--newlines must specify a positive number of newlines");
+			semanticError(
+		"--newlines must specify a positive number of newlines");
 		}
 		if (dateFmtStr) {
 			evl_time_format = dateFmtStr;
@@ -543,7 +471,8 @@ checkSemantics()
 	badOptionCombo("--templates", "--notemplates");
 
 	if (nTailRecs == 0 || nTailRecs < -1) {
-		semanticError("--tail must specify a positive number of records");
+		semanticError(
+			"--tail must specify a positive number of records");
 	}
 
 	if (formatWithoutTemplates) {
@@ -560,123 +489,61 @@ checkSemantics()
 		if (acceptNonStdAtts) {
 			purpose |= EVL_PRPS_TEMPLATE;
 		}
+
 		filter = &query;
 		status = posix_log_query_create(filterStr, purpose, filter,
-			errbuf, 200);
+							errbuf, 200);
+
 		if (status == EINVAL) {
-			fprintf(stderr, "%s: --filter string: %s\n", progName,
-				errbuf);
+			(void) fprintf(stderr, "%s: --filter string: %s\n",
+							progName, errbuf);
 			exit(1);
 		} else if (status != 0) {
-			fprintf(stderr, "%s: internal error: ", progName);
+			(void) fprintf(stderr, "%s: internal error: ",
+								progName);
 			errno = status;
 			perror("posix_log_query_create");
 			exit(2);
 		}
 	}
 
-	if (newFlag) {
-		static struct sigevent nfy;
-		static struct sigaction nfyAction;
-		int status;
-
-		if (filterStr) {
-			int purpose = POSIX_LOG_PRPS_NOTIFY;
-			nfyFilter = &nfyQuery;
-			status = posix_log_query_create(filterStr, purpose,
-				nfyFilter, NULL, 0);
-			if (status != 0) {
-				/*
-				 * Query expression was valid for seeking,
-				 * but not notification.  Just ask to be
-				 * notified about every event, and let the
-				 * seek filter sort it out.
-				 */
-				nfyFilter = NULL;
-			}
-		} else {
-			nfyFilter = NULL;
-		}
-
-		/* Set up signal handler. */
-		(void) memset(&nfyAction, 0, sizeof(nfyAction));
-		nfyAction.sa_sigaction = nfyHandler;
-		nfyAction.sa_flags = SA_SIGINFO;
-		if (sigaction(SIGRTMIN+1, &nfyAction, NULL) < 0) {
-			fprintf(stderr, "%s: internal error: ", progName);
-			perror("sigaction for notification");
-			exit(2);
-		}
-
-		/*
-		 * Register to be notified about new events.  Note that it's OK
-		 * if we start getting notifications right away.
-		 */
-		nfy.sigev_notify = SIGEV_SIGNAL;
-		nfy.sigev_signo = SIGRTMIN+1;
-		nfy.sigev_value.sival_int = 0;	/* not used */
-		status = posix_log_notify_add(nfyFilter, &nfy,
-			POSIX_LOG_SEND_SIGVAL, NULL);
-		if (status != 0) {
-			fprintf(stderr, "%s: internal error: ", progName);
-			errno = status;
-			perror("posix_log_notify_add");
-			if (status == EAGAIN) {
-				fprintf(stderr,
-					"evlnotifyd may not be running.\n");
-			}
-			exit(2);
-		}
+	if (separator) {
+		/* Convert \n, \t, etc. */
+		separator = parseSeparator(separator);
+	} else {
+		separator = defaultSeparator;
 	}
 
 	if (specialFormat) {
 		char *errMsg;
+
 #ifdef TEST_EVREC_SPRINTF
 		specialFormat2 = strdup(specialFormat);
 #endif
 		parsedSpecialFmt = _evlParseFormat(specialFormat,
-			acceptNonStdAtts, &errMsg);
+						acceptNonStdAtts, &errMsg);
+
 		if (!parsedSpecialFmt) {
-			fprintf(stderr, "%s: %s\n", progName, errMsg);
+			(void) fprintf(stderr, "%s: %s\n", progName, errMsg);
 			exit(1);
 		}
+
 		fdbuf = _evlAllocateFmtBuf(parsedSpecialFmt, &fdbufLen);
 		doWeNeedTemplateForSpecialFormat();
 	} else if (format != FMT_BIN) {
 		fdbufLen = _evlGetMaxDumpLen();
 		assert(fdbufLen > 1000);
-		fdbuf = (char*) malloc(fdbufLen);
+		fdbuf = (char *) malloc(fdbufLen);
 		assert(fdbuf != NULL);
 	}
 
-	status = posix_log_open(&logdesc, logPath);
-	if (status == EBUSY) {
-		if (viewingActiveLog) {
-			awaitEndOfLogMaint();
-		} else {
-			fprintf(stderr,
-"%s: Cannot open log file %s because it is inactive but marked busy\n",
-				progName, logPath);
-			/*
-			 * TODO: Add a root-only option to patch the
-			 * generation number in an inactive log so we can
-			 * read it even under these circumstances.
-			 */
-			exit(1);
-		}
-	} else if (status != 0) {
-		fprintf(stderr, "%s: Cannot open log file\n", progName);
-		errno = status;
-		perror(logPath ? logPath : LOG_CURLOG_PATH);
-		exit(1);
-	}
-
 	if (outPath) {
 		struct stat64 st;
 		outFile = NULL;
 		outFd = open64(outPath, O_WRONLY|O_APPEND|O_CREAT, 0666);
 		if (outFd < 0) {
-			fprintf(stderr, "%s: Cannot append to file\n", progName);
+			(void) fprintf(stderr, "%s: Cannot append to file\n",
+								progName);
 			perror(outPath);
 			exit(1);
 		}
@@ -688,7 +555,7 @@ checkSemantics()
 		}
 		if (st.st_size == 0) {
 			if (_evlWriteLogHeader(outFd) < 0) {
-				fprintf(stderr,
+				(void) fprintf(stderr,
 					"%s: Cannot write log header to file\n",
 					progName);
 				perror(outPath);
@@ -699,13 +566,6 @@ checkSemantics()
 		outFd = 1;
 		outFile = stdout;
 	}
-
-	if (separator) {
-		/* Convert \n, \t, etc. */
-		separator = parseSeparator(separator);
-	} else {
-		separator = defaultSeparator;
-	}
 }
 
 /*
@@ -720,19 +580,20 @@ getPopulatedTemplate(const struct posix_
 	evltemplate_t *tmpl;
 
 	status = evl_gettemplate(entry, buf, &tmpl);
-	if (status == ENOENT) {
-		/* No such template. */
-		return NULL;
-	} else if (status != 0) {
+	if (status != 0) {
+		if (status == ENOENT) {
+			/* No such template. */
+			return NULL;
+		}
+
 		errno = status;
 		perror("evl_gettemplate");
 		exit(1);
 	}
 
 	/* tmpl is a clone of the template for this facility and event type.  */
-	if (tmpl->tm_recid != entry->log_recid
-	    || tmpl->tm_entry != entry
-	    || tmpl->tm_data != buf) {
+	if (tmpl->tm_recid != entry->log_recid ||
+			tmpl->tm_entry != entry || tmpl->tm_data != buf) {
 		/*
 		 * It's not yet populated with the values from this
 		 * record.
@@ -820,16 +681,24 @@ formatLikeSyslog(const struct posix_log_
 	struct tm tm;
 
 	len = strftime(fdbuf, fdbufLen, "%b %e %H:%M:%S ",
-			localtime_r(&timestamp, &tm));
+						localtime_r(&timestamp, &tm));
+
 	assert(len != 0);
 	(void) strcat(fdbuf, _evlGetHostNameEx( entry->log_processor >> 16));
 	(void) strcat(fdbuf, " ");
+
 	if ((entry->log_flags & EVL_KERNEL_EVENT) != 0) {
 		(void) strcat(fdbuf, "kernel: ");
 	}
+
 	(void) fprintf(outFile, "%s", fdbuf);
 
-	if ((entry->log_flags & EVL_PRINTK) != 0) {
+	if (entry->log_flags & EVL_PRINTK) {
+		status = evl_format_evrec_variable(entry, buf,
+						fdbuf, fdbufLen, NULL);
+		assert(status == 0 || status == EMSGSIZE);
+		printStringWithNewlines(fdbuf, 0);
+	} else {
 		switch (entry->log_format) {
 		case POSIX_LOG_NODATA:
 			/* Shouldn't happen. */
@@ -851,11 +720,6 @@ formatLikeSyslog(const struct posix_log_
 			printStringWithNewlines(fdbuf, 0);
 			break;
 		}
-	} else {
-		status = evl_format_evrec_variable(entry, buf,
-			fdbuf, fdbufLen, NULL);
-		assert(status == 0 || status == EMSGSIZE);
-		printStringWithNewlines(fdbuf, 0);
 	}
 }
 
@@ -883,7 +747,7 @@ copyRecord(const struct posix_log_entry 
 			flags = EVL_COMPACT;
 		}
 		status = evl_format_evrec_fixed(entry, fdbuf, fdbufLen,
-			NULL, separator, linelen, flags);
+					NULL, separator, linelen, flags);
 		if (status != 0) {
 			errno = status;
 			perror("evl_format_evrec_fixed");
@@ -892,8 +756,8 @@ copyRecord(const struct posix_log_entry 
 		(void) fprintf(outFile, "%s\n", fdbuf);
 
 		/* Now the variable part... */
-		if (format == FMT_NEQV
-		    && (tmpl = getPopulatedTemplate(entry, buf)) != NULL) {
+		if (format == FMT_NEQV &&
+			(tmpl = getPopulatedTemplate(entry, buf)) != NULL) {
 			status = evltemplate_neqvdump(tmpl, fdbuf, fdbufLen);
 		} else {
 			status = evl_format_evrec_variable(entry, buf, fdbuf,
@@ -905,24 +769,28 @@ copyRecord(const struct posix_log_entry 
 	    }
 	case FMT_SPEC:
 #ifdef TEST_EVREC_SPRINTF
-	    {
-		size_t reqlen;
-		status = evl_format_evrec_sprintf(entry, buf, specialFormat2,
-			fdbuf, fdbufLen, &reqlen);
-	    	if (status != 0) {
-			errno = status;
-			perror("evl_format_evrec_sprintf");
-			fprintf(stderr, "reqlen = %u\n", reqlen);
-			exit(2);
+		{
+			size_t reqlen;
+
+			status = evl_format_evrec_sprintf(entry, buf,
+					specialFormat2, fdbuf, fdbufLen,
+					&reqlen);
+
+			if (status != 0) {
+				errno = status;
+				perror("evl_format_evrec_sprintf");
+				(void) fprintf(stderr, "reqlen = %u\n", reqlen);
+				exit(2);
+			}
 		}
-	    }
 #else
 		tmpl = NULL;
 		if (needTemplateForSpecialFormat) {
 			tmpl = getPopulatedTemplate(entry, buf);
 		}
+
 		_evlSpecialFormatEvrec(entry, buf, tmpl, parsedSpecialFmt,
-			fdbuf, fdbufLen, NULL);
+							fdbuf, fdbufLen, NULL);
 	    	if (tmpl) {
 			evl_releasetemplate(tmpl);
 		}
@@ -940,94 +808,96 @@ copyRecord(const struct posix_log_entry 
 	 * Given 'evlview -n > file', ensure that the records show up in
 	 * file right away.
 	 */
-	if (newFlag && format != FMT_BIN) {
-		(void) fflush(stdout);
-	}
 
-	lastRecordCopied = entry->log_recid;
+	if (newFlag && format != FMT_BIN)
+		(void) fflush(stdout);
 }
 
 /*
- * logdesc's read pointer points at the next record to read (or EOF).
+ * logDesc's read pointer points at the next record to read (or EOF).
  * Read the record and copy it to the output stream in the format previously
  * specified by the user.
  * If we hit end of file, return -1.
- * If the read fails because of a log-management event, we return -2.  In this
- *	case, we return with the read pointer set as indicated by resyncAction.
  * If the read fails for any other reason, print an error message and exit.
  * Return 0 on success.
  */
+
 static int
-readAndCopyRecord(int resyncAction)
+readAndCopyRecord(void)
 {
 	struct posix_log_entry entry;
 	char buf[POSIX_LOG_ENTRY_MAXLEN];
 	int status;
 	
-	status = posix_log_read(logdesc, &entry, buf, POSIX_LOG_ENTRY_MAXLEN);
+	status = posix_log_read(logDesc, &entry, buf, POSIX_LOG_ENTRY_MAXLEN);
 	if (status != 0) {
 		if (status == EAGAIN) {
 			/* end of file */
 			return -1;
 		}	
-		handleReadOrSeekFailure(status, "read", resyncAction);
-		return -2;
+
+		(void) fprintf(stderr, "%s: read error: %d\n",
+							progName, status);
+		exit(1);
 	}
 	copyRecord(&entry, buf);
 	return 0;
 }
 
+static void
+seekToEnd(void)
+{
+	int status = posix_log_seek(logDesc, NULL, POSIX_LOG_SEEK_END);
+
+	if (status != 0) {
+		(void) fprintf(stderr, "%s: seek error: %d\n",
+						progName, status);
+
+		exit(1);
+	}
+}
+
 /*
  * Seek to the end of the log; then read backward through the log, copying
  * all records that match the filter.  If nTailRecs > 0, copy at most that
  * many records.
  */
 static void
-copyBackward()
+copyBackward(void)
 {
 	int i, status;
 
-startOver:
 	seekToEnd();
 
 	for (i = 1; nTailRecs == -1 || i <= nTailRecs; i++) {
-		status = posix_log_seek(logdesc, filter, POSIX_LOG_SEEK_BACKWARD);
-		if (status == ENOENT) {
-			/* No matching record found. */
-			return;
-		} else if (status != 0) {
-			handleReadOrSeekFailure(status, "seek backward",
-				LMRESYNC_BEFORELAST);
-			if (lastRecordCopied == -1) {
-				goto startOver;
+		status = posix_log_seek(logDesc, filter,
+						POSIX_LOG_SEEK_BACKWARD);
+
+		if (status != 0) {
+			if (status == ENOENT) {
+				/* No matching record found. */
+				return;
 			}
-			/* Redo this iteration. */
-			i--;
-			continue;
+
+			(void) fprintf(stderr, "%s: seek error: %d\n",
+						progName, status);
+
+			exit(1);
 		}
 
-		status = readAndCopyRecord(LMRESYNC_BEFORELAST);
+		status = readAndCopyRecord();
 		if (status == -1) {
 			/* EOF */
 			return;
-		} else if (status == -2) {
-			/* Interrupted by log maintenance */
-			if (lastRecordCopied == -1) {
-				goto startOver;
-			}
-			i--;
-			continue;
 		}
 
-		status = posix_log_seek(logdesc, NULL, POSIX_LOG_SEEK_BACKWARD);
+		/* Seek one record before the current record */
+		status = posix_log_seek(logDesc, NULL, POSIX_LOG_SEEK_BACKWARD);
 		if (status != 0) {
-			handleReadOrSeekFailure(status,
-				"seek backward past record just read",
-				LMRESYNC_BEFORELAST);
-			/*
-			 * readAndCopyRecord() has already succeeded,
-			 * so no need to redo this iteration.
-			 */
+			(void) fprintf(stderr, "%s: seek error: %d\n",
+						progName, status);
+
+			exit(1);
 		}
 	}
 }
@@ -1036,45 +906,35 @@ startOver:
  * From the current position in the log, read through the log, copying
  * all records that match the filter.  If nTailRecs > 0, copy at most that
  * many records.
- *
- * Return -2 if we get interrupted by a log-maintenance operation and can't
- * get resync-ed.  (This happens only if we get interrupted before the process
- * copies its first record.)  Otherwise return 0.
  */
 static int
-copyForward()
+copyForward(void)
 {
-	int i, status;
+	int i;
+
 	for (i = 1; nTailRecs == -1 || i <= nTailRecs; i++) {
-		if (filter) {
-			status = posix_log_seek(logdesc, filter, POSIX_LOG_SEEK_FORWARD);
+		int status;
+
+		status = posix_log_seek(logDesc, filter,
+						POSIX_LOG_SEEK_FORWARD);
+
+		if (status != 0) {
 			if (status == ENOENT) {
-				/* No matching record found. */
-				return 0;
-			} else if (status != 0) {
-				handleReadOrSeekFailure(status, "seek forward",
-					LMRESYNC_AFTERLAST);
-				if (lastRecordCopied == -1) {
-					return -2;
-				}
-				/* Redo this iteration. */
-				i--;
-				continue;
+				/* No matching record found - EOF */
+				break;
 			}
-		}
 
-		status = readAndCopyRecord(LMRESYNC_AFTERLAST);
-		if (status == -1) {
-			/* EOF */
-			return 0;
-		} else if (status == -2) {
-			if (lastRecordCopied == -1) {
-				return -2;
-			}
-			i--;
-			continue;
+			(void) fprintf(stderr, "%s: seek error: %d\n",
+						progName, status);
+
+			exit(1);
 		}
+
+		status = readAndCopyRecord();
+		if (status == -1)
+			break;
 	}
+
 	return 0;
 }
 
@@ -1085,23 +945,27 @@ copyForward()
  * copy them.
  */
 static void
-prepareToTailForward()
+prepareToTailForward(void)
 {
 	int i, status;
 
 	assert(nTailRecs > 0);
 	seekToEnd();
 
-startOver:
 	for (i = 1; i <= nTailRecs; i++) {
-		status = posix_log_seek(logdesc, filter, POSIX_LOG_SEEK_BACKWARD);
-		if (status == ENOENT) {
-			/* No matching record found. */
-			return;
-		} else if (status != 0) {
-			handleReadOrSeekFailure(status, "seek backward",
-				LMRESYNC_END);
-			goto startOver;
+		status = posix_log_seek(logDesc, filter,
+						POSIX_LOG_SEEK_BACKWARD);
+
+		if (status != 0) {
+			if (status == ENOENT) {
+				/* No matching record found. */
+				break;
+			}
+
+			(void) fprintf(stderr, "%s: seek error: %d\n",
+						progName, status);
+
+			exit(1);
 		}
 	}
 }
@@ -1111,7 +975,7 @@ startOver:
  * whose ID is >= n, and copy all matching records from there to EOF.
  */
 static void
-copyOldTail()
+SeekOldTail(void)
 {
 	posix_log_query_t query;
 	char qstring[40];
@@ -1124,454 +988,379 @@ copyOldTail()
 	 * over that.
 	 */
 	snprintf(qstring, sizeof(qstring), "recid < %u", initialRecid);
+
 	status = posix_log_query_create(qstring, POSIX_LOG_PRPS_SEEK,
-		&query, NULL, 0);
+							&query, NULL, 0);
+
 	assert(status == 0);
 
-startOver:
-	status = posix_log_seek(logdesc, &query, POSIX_LOG_SEEK_LAST);
+	status = posix_log_seek(logDesc, &query, POSIX_LOG_SEEK_LAST);
+
 	if (status == 0) {
 		/* Skip over record n-1 by reading it. */
-		status = posix_log_read(logdesc, &entry, NULL, 0);
+		status = posix_log_read(logDesc, &entry, NULL, 0);
+
 		if (status != 0) {
-			handleReadOrSeekFailure(status, "skip to first record",
-				LMRESYNC_START);
-			goto startOver;
+			(void) fprintf(stderr, "%s: read error: %d\n",
+							progName, status);
+			exit(1);
 		}
 	} else if (status != ENOENT) {
-		handleReadOrSeekFailure(status, "seek to first record",
-			LMRESYNC_START);
-		goto startOver;
+		(void) fprintf(stderr, "%s: seek error: %d\n",
+							progName, status);
+		exit(1);
 	}
 	/*
 	 * status == ENOENT means there's no record newer than n.
 	 * If so, we want to start at BOF, and we're there already.
 	 */
-
-	if (copyForward() == -2) {
-		goto startOver;
-	}
 	(void) posix_log_query_destroy(&query);
 }
 
-/*
- * This function implements the --new option.  Run copyForward() whenever
- * our notification handler indicates that a new record of interest has
- * been logged.
- */
-static void
-copyNewRecords()
+static int
+open_log_file(char *path)
 {
-	/*
-	 * We sleep at most 5 seconds at a time, so we can detect within
-	 * that time an event that arrived just before we went to sleep.
-	 */
-	int maxSleep = 5;
 	int status;
 
-startOver:
-	if (initialRecid != -1) {
-		/*
-		 * Note that if we come through here a second time, it
-		 * means that there were no records of interest between
-		 * initialRecid and the original EOF.  However, there
-		 * may be some between the old EOF and the new one, and
-		 * this way we're sure to catch them.
-		 */
-		copyOldTail();
-	} else {
-		seekToEnd();
-	}
+again:
+	status = posix_log_open(&logDesc, path);
 
-	if (timeout != -1) {
-		int slept, totalSlept;
-		for (;;) {
-			/* Copy new events until they stop arriving. */
-			while (writeCount != nfyCount) {
-				writeCount = nfyCount;
-				if (copyForward() == -2) {
-					goto startOver;
-				}
-			}
+	switch (status) {
+	case 0:
+		if (!viewingActiveLog)
+			status = _evlLockLog(logDesc, F_RDLCK);
 
-			/*
-			 * Sleep until a new event arrives or until the
-			 * timeout interval passes with no new events.
-			 * Note that arrival of the notification signal will
-			 * terminate sleep().
-			 */
-			for (totalSlept = 0;
-			    totalSlept < timeout;
-			    totalSlept += slept) {
-				int sleepThisMuch = timeout - totalSlept;
-				if (sleepThisMuch > maxSleep) {
-					sleepThisMuch = maxSleep;
-				}
-				slept = sleepThisMuch - sleep(sleepThisMuch);
-				if (writeCount != nfyCount) {
-					/* A new event has arrived. */
-					break;
-				}
-			}
-			if (writeCount == nfyCount) {
-				/* Timed out, no event. */
-				exit(0);
-			}
-			/* A new event has arrived.  Go back to the top. */
-		}
-	} else {
-		/* No timeout.  Read and write records until they kill us. */
-		for (;;) {
-			while (writeCount != nfyCount) {
-				writeCount = nfyCount;
-				if (copyForward() == -2) {
-					goto startOver;
-				}
-			}
-			while (writeCount == nfyCount) {
-				sleep(maxSleep);
-			}
+		break;
+
+	case EBUSY:
+		if (viewingActiveLog) {
+			(void) fprintf(stderr,
+				"%s: Active log file %s is marked busy\n",
+				progName, logPath);
+
+			exit(1);
 		}
-	}
+
+		(void) sleep(1);
+		goto again;
+		break;
+
+	default:
+		break;
 }
 
-static void
-seekToEnd()
-{
-	int status = posix_log_seek(logdesc, NULL, POSIX_LOG_SEEK_END);
-	if (status != 0) {
-		handleReadOrSeekFailure(status, "seek to end", LMRESYNC_END);
-	}
+	return status;
 }
 
-/*
- * What's a reasonable amount of time to wait for completion of the
- * log-maintenance operation that interrupted us?
- * 1. If a timeout was specified with --timeout, use that.
- * 2. Figure 0.5 seconds per MByte of log file is very generous.
- * 3. No matter what number we get from #2, never give up in less than 10
- * seconds or wait more than 5 minutes.
- */
+#define	STAT_RETRIES	5
+
 static int
-computeLogMgmtTimeout()
+stat_with_retries(char *path, struct stat64 *statbuf)
 {
-	int lmTimeout;
-	const char *path = logPath;
-	struct stat64 st;
-	double secondsPerMbyte = 0.5;
-	int minTimeout = 10, maxTimeout = 5*60;
+	int		erc;
 
-	if (timeout > 0) {
-		return timeout;
-	}
+	unsigned int	retries = STAT_RETRIES;
 
-	if (!path) {
-		path = LOG_CURLOG_PATH;
-	}
-	if (stat64(path, &st) != 0) {
-		fprintf(stderr, "%s: stat of log file failed.\n", progName);
-		perror(path);
-		exit(2);
-	}
-	lmTimeout = secondsPerMbyte * (st.st_size / (1000*1000));
-	if (lmTimeout < minTimeout) {
-		lmTimeout = minTimeout;
-	} else if (lmTimeout > maxTimeout) {
-		lmTimeout = maxTimeout;
+	while (1) {
+		(void) memset((void *) statbuf, 0, sizeof(*statbuf));
+
+		if (stat64(path, statbuf) == -1) {
+			if (retries-- == 0)
+				break;
+			else
+				(void) sleep(1);
+		}
+		else {
+			errno = 0;
+			break;
+		}
 	}
-	return lmTimeout;
+
+	return errno;
 }
 
-/*
- * Access to the log file has failed in a way that indicates that log
- * maintenance is underway.  The log has been closed (or never successfully
- * opened).  We try to reopen it immediately, again upon the arrival of a
- * POSIX_LOG_MGMT_ENDMAINT event, and again upon termination of a timeout.
- * We return on success.  If the timeout expires and our last try fails,
- * we print an error message and exit.
- */
-static void
-awaitEndOfLogMaint()
+#define	LOG_CHANGE_NEW		0
+#define	LOG_CHANGE_GREW		1
+#define	LOG_CHANGE_TIMEOUT	2
+
+static int
+log_monitor(struct stat64 *old)
 {
-	int lmTimeout;
-	time_t now, deadline;
-	int generation;
-	int status;
+	int erc;
+	int slept;
 
-	LMDEBUG("Awaiting end of log maintenance operation...\n");
+	int toSleep = 1;
+	int maxSleep = 5;
+	int totalSlept = 0;
 
-	lmTimeout = computeLogMgmtTimeout();
-	(void) time(&now);
-	deadline = now + lmTimeout;
-
-	if (!registeredForEndMaintEvents) {
-		if (registerForEndMaintEvents() == -1) {
-			/* Notification daemon unavailable. */
-			fprintf(stderr,
-"%s: Interrupted by evlogmgr, and evlnotifyd not running.  Cannot recover.\n",
-				progName);
-			exit(2);
-		}
-	}
+	while (1) {
+		struct stat64	newStatBuf;
 
-	for (;;) {
-		generation = logGeneration;
-		status = posix_log_open(&logdesc, logPath);
-		if (status == 0) {
-			LMDEBUG("Successfully reopened log.\n");
-			return;
-		}
-		if (status != EBUSY) {
-			fprintf(stderr,
-"%s: Log file was busy, but now cannot be opened at all!\n",
-				progName);
-			exit(2);
+		/* sleep for a bit */
+		slept = sleep(toSleep);
+
+		/*
+		 * Bail out if there is a maximum sleep limit set
+		 * and it has been exceeded.
+		 */
+
+		if (timeout != -1) {
+			totalSlept += slept;
+
+			if (totalSlept > timeout) {
+				erc = LOG_CHANGE_TIMEOUT;
+				break;
+			}
 		}
 
-		if (now >= deadline) {
-			/* Timed out, no end-maintenance event. */
-			fprintf(stderr,
-"%s: Log file is inaccessible, apparently due to ongoing maintenance.\n"
-"Timed out after %d seconds.\n",
-				progName, lmTimeout);
-			exit(2);
+		erc = stat_with_retries(logPath, &newStatBuf);
+
+		if (erc != 0) {
+			(void) fprintf(stderr, "%s: fstat on %s failed: %s\n",
+							progName, logPath,
+							strerror(erc));
+
+			exit(1);
 		}
 
 		/*
-		 * Sleep until an end-maint event arrives (and increments
-		 * log_generation) or until the timeout interval passes.
-		 * Note that arrival of any notification signal will
-		 * terminate sleep().
+		 * Compare the log file, before and after the sleep, and
+		 * determine what action is to be taken.
 		 */
-		while (now < deadline && generation == logGeneration) {
-			sleep(deadline - now);
-			(void) time(&now);
+
+		if (Debug) {
+			(void) fprintf(stderr,
+				"%s: st_ctime old %X new %X\n",
+				progName, old->st_ctime, newStatBuf.st_ctime);
+			(void) fprintf(stderr,
+				"%s: st_mtime old %X new %X\n",
+				progName, old->st_mtime, newStatBuf.st_mtime);
+			(void) fprintf(stderr,
+				"%s: st_ino old %llX new %llX\n",
+				progName, old->st_ino, newStatBuf.st_ino);
+			(void) fprintf(stderr,
+				"%s: st_size old %lld new %lld\n",
+				progName, old->st_size, newStatBuf.st_size);
+		}
+
+		if (old->st_ino == newStatBuf.st_ino) {
+			if ((newStatBuf.st_mtime == old->st_mtime) &&
+			    (newStatBuf.st_size == old->st_size)) {
+				if (toSleep < maxSleep)
+					toSleep++;
+			}
+			else {
+				/* modified log files only grow */
+				erc = LOG_CHANGE_GREW;
+				break;
+			}
+		}
+		else {
+			erc = LOG_CHANGE_NEW;
+			break;
 		}
+	}
 
-		/*
-		 * Even if we've timed out, go back and try one more time
-		 * to open the log.
-		 */
+	if (Debug) {
+		(void) fprintf(stderr, "%s: log_monitor result: %d\n",
+			progName, erc);
 	}
-}
 
-/*
- * This object encodes what kind of seek we have to do after successfully
- * reopening the log after a log-maintenance operation.
- */
-struct resyncStrategy {
-	posix_log_query_t	rsQuery;	/* seek query */
-	int	rsQueryNeeded;	/* Is rsQuery meaningful? */
-	int	rsDirection;	/* seek direction */
-	int	rsNoentDxn;	/* What to do if 1st seek fails with ENOENT */
-	int	rsJustSeek;	/* 1 if all we do is seek once */
-};
+	return (erc);
+}
 
 /*
- * Populate rs with the resync strategy needed to accomplish the indicated
- * resync action.
+ * This function implements the --new option.  Run copyForward() whenever
+ * our notification handler indicates that a new record of interest has
+ * been logged.
  */
 static void
-figureResyncStrategy(int resyncAction, struct resyncStrategy *rs)
+copyNewRecords(void)
 {
-	const char *op;
-	char queryString[100];
-	int status;
+	/*
+	 * Position the log to the correct starting location.
+	 */
 
-	assert(resyncAction == LMRESYNC_BEFORELAST
-		|| resyncAction == LMRESYNC_AFTERLAST);
+	if (initialRecid == -1)
+		seekToEnd();
+	else
+		SeekOldTail();
 
-	if (newFlag || nTailRecs != -1) {
-		/*
-		 * It's probably more efficient to seek from EOF.
-		 * Seek backward to the last record whose recid is <=
-		 * lastRecordCopied.  (After that the caller will have to
-		 * do some more poking around to make sure we're in the
-		 * right place.)  If that seek finds no record (i.e.,
-		 * lastRecordCopied and all earlier records are gone),
-		 * just seek to BOF.
-		 */
-		op = "<=";
-		rs->rsDirection = POSIX_LOG_SEEK_LAST;
-		rs->rsNoentDxn = POSIX_LOG_SEEK_START;
-		rs->rsJustSeek = 0;
-	} else {
-		/*
-		 * Seek forward to the first record whose recid is > (or >=)
-		 * lastRecordCopied.  If that seek finds no record (i.e.,
-		 * all later records are gone), just seek to EOF.
-		 */
-		rs->rsDirection = POSIX_LOG_SEEK_FIRST;
-		rs->rsNoentDxn = POSIX_LOG_SEEK_END;
-		rs->rsJustSeek = 1;
-		if (resyncAction == LMRESYNC_BEFORELAST) {
-			op = ">=";
-		} else {
-			op = ">";
+	/*
+	 * Process the log data.
+	 */
+
+	if (viewingActiveLog) {
+		while (1) {
+			int		erc;
+			struct stat64	oldStatBuf;
+
+			(void) memset((void *) &oldStatBuf, 0,
+							sizeof(oldStatBuf));
+
+			erc = _evlFstatLog(logDesc, &oldStatBuf);
+
+			if (erc != 0) {
+				(void) fprintf(stderr,
+				"%s: Active log file fstat failed: %s\n",
+					progName, strerror(erc));
+
+				exit(1);
+			}
+
+			/* process all events until EOF */
+			(void) copyForward();
+
+			/* wait for a change or a timeout */
+			erc = log_monitor(&oldStatBuf);
+
+			/* timed out? bail! */
+			if (erc == LOG_CHANGE_TIMEOUT)
+				break;
+
+			/* Changes! Handle them accordingly */
+			if (erc == LOG_CHANGE_NEW) {
+				/*
+				 * Some events may have dribbled in during
+				 * the last sleep. Deal with them...
+				 */
+
+				(void) copyForward();
+
+				/* close the log file */
+				(void) posix_log_close(logDesc);
+
+				/* open the new log file */
+				(void) open_log_file(logPath);
+			}
 		}
 	}
-	rs->rsQueryNeeded = 1;
-	snprintf(queryString, sizeof(queryString), "recid %s %d", op, lastRecordCopied);
-	status = posix_log_query_create(queryString, POSIX_LOG_PRPS_SEEK,
-		&rs->rsQuery, NULL, 0);
-	if (status != 0) {
-		fprintf(stderr, "%s: internal error: bad query in figureResyncStrategy()\n",
-			progName);
-		errno = status;
-		perror("posix_log_query_create");
-		exit(2);
+	else {
+		/* process all events until EOF */
+		(void) copyForward();
 	}
 }
 
-/*
- * A posix_log_read or posix_log_seek operation has failed.  If the log
- * is active, and the failure is EBADF (indicating that a log
- * maintenance operation has started), we close the log, wait until the log
- * maintenance operation is done, open the log, and put the read pointer
- * back where it needs to be (as indicated by resyncAction).
- *
- * Otherwise, we report the error and exit.
- */
 static void
-handleReadOrSeekFailure(int failure, const char *operation, int resyncAction)
+process_one_log( void )
 {
-	struct resyncStrategy rs;
 	int status;
-	struct posix_log_entry entry;
 
-	if (!viewingActiveLog || failure != EBADF) {
-		reportReadOrSeekFailure(failure, operation);
-		exit(2);
-	}
+	status = open_log_file(logPath);
 
-	LMDEBUG("Interrupted by log maintenance.  Last record copied = %d\n",
-		lastRecordCopied);
+	if (status != 0) {
+		(void) fprintf(stderr,
+				"%s: Cannot open log file (%s): %s\n",
+				progName, logPath, strerror(status));
 
-	/*
-	 * If we're going to have to resync on the last record copied,
-	 * set up the necessary query.  Note that this has to work even if
-	 * lastRecordCopied is no longer in the log.
-	 *
-	 * If no record has been copied yet, we'll just leave the read
-	 * pointer at BOF.
-	 */
-	if (lastRecordCopied != -1
-	    && (resyncAction == LMRESYNC_BEFORELAST
-	    || resyncAction == LMRESYNC_AFTERLAST)) {
-		figureResyncStrategy(resyncAction, &rs);
-	} else {
-		rs.rsQueryNeeded = 0;
-		rs.rsJustSeek = 1;
+		exit(1);
 	}
 
-tryAgain:
-	(void) posix_log_close(logdesc);
-	awaitEndOfLogMaint();
+	if (newFlag)
+		copyNewRecords();
+	else if (reverse)
+		copyBackward();
+	else if (nTailRecs > 0) {
+		prepareToTailForward();
+		(void) copyForward();
+	} else
+		(void) copyForward();
 
-	/*
-	 * We have successfully reopened the log.  Now put the read pointer
-	 * back where the caller wants it.
-	 */
-	if (resyncAction == LMRESYNC_START || lastRecordCopied == -1) {
-		goto finish;
-	}
-	
-	switch (resyncAction) {
-	case LMRESYNC_END:
-		status = posix_log_seek(logdesc, NULL, POSIX_LOG_SEEK_END);
-		break;
-	case LMRESYNC_BEFORELAST:
-	case LMRESYNC_AFTERLAST:
-		status = posix_log_seek(logdesc, &rs.rsQuery, rs.rsDirection);
-		break;
+	if (!viewingActiveLog)
+		(void) _evlUnlockLog(logDesc);
+
+	(void) posix_log_close(logDesc);
+
+	return;
+}
+
+static void
+process_multiple_logs( void )
+{
+	FILE	*stream;
+	char	line[PATH_MAX];
+	int	empty = 1;
+
+	stream = fopen(multiPath, "r");
+
+	if (stream == (FILE *) NULL) {
+		(void) fprintf(stderr,
+				"%s: Cannot open log file (%s): %s\n",
+				progName, logPath, strerror(errno));
+
+		exit(1);
 	}
-	if (status == EBADF) {
-		/* Log maintenance again! */
-		goto tryAgain;
-	} else if (status == ENOENT) {
-		/* No match.  Just go to BOF or EOF, as appropriate. */
-		status = posix_log_seek(logdesc, NULL, rs.rsNoentDxn);
-		if (status == EBADF) {
-			goto tryAgain;
-		} else if (status != 0) {
-			reportReadOrSeekFailure(status, "resync #2 after log maintenance");
+
+	while (fgets(line, 1024, stream) != NULL) {
+		char *p;
+		int status;
+
+		empty = 0;
+
+		logPath = line;
+
+		p = strchr(logPath, '\n');
+		if (p != (char *) NULL)
+			*p = '\0';
+
+		if ((strcmp(logPath, LOG_PRIVATE_PATH) == 0) ||
+		    (strcmp(logPath, LOG_CURLOG_PATH) == 0))
+			viewingActiveLog = 1;
+		else
+			viewingActiveLog = 0;
+
+		status = open_log_file(logPath);
+
+		if (status != 0) {
+			(void) fprintf(stderr,
+					"%s: Cannot open log file (%s): %s\n",
+					progName, logPath, strerror(status));
+
+			exit(1);
 		}
-		goto finish;
-	} else if (status != 0) {
-		reportReadOrSeekFailure(status, "resync after log maintenance");
-	}
 
-	/* We successfully completed the seek prescribed in our strategy. */
-	if (rs.rsJustSeek) {
-		goto finish;
-	}
+		(void) copyForward();
 
-	/* We must have sought backward from EOF.  Still not done. */
-	status = posix_log_read(logdesc, &entry, NULL, 0);
-	if (status == EBADF) {
-		goto tryAgain;
-	} else if (status != 0) {
-		reportReadOrSeekFailure(status, "resync #3 after log maintenance");
-	}
-	if (rs.rsDirection == POSIX_LOG_SEEK_LAST
-	    && resyncAction == LMRESYNC_AFTERLAST) {
-		/*
-		 * We sought backward to the last record <= lastRecordCopied.
-		 * Then we advanced the read pointer past that record.
-		 * No matter what that record is, we're done.
-		 */
-		goto finish;
-	}
-	assert(rs.rsDirection == POSIX_LOG_SEEK_LAST
-	    && resyncAction == LMRESYNC_BEFORELAST);
-	if (entry.log_recid != lastRecordCopied) {
-		/*
-		 * lastRecordCopied has been deleted.  The read pointer is
-		 * now where lastRecordCopied used to be.
-		 */
-		goto finish;
-	}
+		if (!viewingActiveLog)
+			(void) _evlUnlockLog(logDesc);
 
-	/*
-	 * As it turns out, we sought backward to the beginning of
-	 * lastRecordCopied, then read past it.  Back up one.
-	 */
-	status = posix_log_seek(logdesc, NULL, POSIX_LOG_SEEK_BACKWARD);
-	if (status == EBADF) {
-		goto tryAgain;
-	} else if (status != 0) {
-		reportReadOrSeekFailure(status, "resync #4 after log maintenance");
+		(void) posix_log_close(logDesc);
 	}
 
-finish:
-	LMDEBUG("Recovered from log-maintenance interruption.\n");
-	if (rs.rsQueryNeeded) {
-		(void) posix_log_query_destroy(&rs.rsQuery);
+	(void) fclose(stream);
+
+	if (empty) {
+		(void) fprintf(stderr, "%s: empty multi file (%s)\n",
+							progName, logPath);
+
+		exit(1);
 	}
+
 }
 
 main(int argc, char **argv)
 {
-	int status;
+	char *p;
+
+	p = strrchr(argv[0], '/');
+
+	if (p == (char *) NULL) {
+		progName = argv[0];
+	}
+	else {
+		progName = p + 1;
+	}
 
-	progName = argv[0];
 	(void) setlocale(LC_ALL, "");
 	processArgs(argc, argv);
 	checkSemantics();
 
-	if (newFlag) {
-		copyNewRecords();
-	} else if (reverse) {
-		copyBackward();
-	} else if (nTailRecs > 0) {
-		do {
-			prepareToTailForward();
-			status = copyForward();
-		} while (status == -2);
-	} else {
-		do {
-			status = copyForward();
-		} while (status == -2);
+	if (multiPath == (char *) NULL) {
+		process_one_log();
+	}
+	else {
+		process_multiple_logs();
 	}
+
 	exit(0);
 }
Index: evlog-1.6.1/user/include/posix_evlsup.h
===================================================================
--- evlog-1.6.1.orig/user/include/posix_evlsup.h
+++ evlog-1.6.1/user/include/posix_evlsup.h
@@ -46,10 +46,10 @@ struct _evlNvPair {
 /* An entry from the facility registry */
 typedef struct __evlFacility {
 	posix_log_facility_t	faCode;
-	char					*faName;
-	int						faAccessFlags;
-	char 					*faFilter;
-	posix_log_query_t		*faQuery;
+	char			*faName;
+	int			faAccessFlags;
+	char 			*faFilter;
+	posix_log_query_t	*faQuery;
 } _evlFacility;
 
 /* Internal view of the info in /etc/evlog.d/facility_registry */
@@ -104,6 +104,23 @@ extern int _evlFdWrite(int fd, const str
 	const void *buf);
 extern int _evlWriteLogHeader(int fd);
 extern int _evlValidateQuery(posix_log_query_t *query, int nullOk);
+extern int _evlLockLog(posix_logd_t logdes, int lock_bits);
+extern int _evlUnlockLog(posix_logd_t logdes);
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+extern int
+_evlFstatLog(posix_logd_t logdes,
+
+#if defined(_LARGEFILE64_SOURCE)
+struct stat64
+#else
+struct stat
+#endif
+
+*statbuf);
 
 /* facility registry functions */
 extern void _evlLockFacReg(void);
Index: evlog-1.6.1/user/lib/posix2.c
===================================================================
--- evlog-1.6.1.orig/user/lib/posix2.c
+++ evlog-1.6.1/user/lib/posix2.c
@@ -732,6 +732,70 @@ unlock_and_exit:
 }
 
 /*
+ * cmd is F_GETLK64 see if lock exists on a file descriptor fd,
+ * or F_SETLK64 set a lock on file descriptor fd,
+ * or F_SETLKW64, the blocking version of F_SETLK64.
+ * Process sleeps until lock can be obtained.
+ */
+
+static int
+file_lock(int fd, int cmd, int type)
+{
+	struct flock64 lock;
+
+	lock.l_type = type;		/* F_RDLCK, F_WRLCK, or F_UNLOCK */
+	lock.l_len = lock.l_start = 0;	/* byte offset l_whence relative */
+	lock.l_whence = SEEK_SET;	/* or SEEK_CUR or SEEK_END */
+
+	return fcntl(fd, cmd, &lock);
+}
+
+/*
+ * File locking routines
+ */
+
+int
+_evlLockLog(posix_logd_t logdes, int lock_bits)
+{
+	int fd = logdToFd(logdes);
+
+	return file_lock(fd, F_SETLKW64, lock_bits) == -1 ? errno : 0;
+}
+
+int
+_evlUnlockLog(posix_logd_t logdes)
+{
+	int fd = logdToFd(logdes);
+
+	return file_lock(fd, F_SETLKW64, F_UNLCK) == -1 ? errno : 0;
+}
+
+/*
+ * stat routine.
+ */
+
+int
+_evlFstatLog(posix_logd_t logdes,
+
+#if defined(_LARGEFILE64_SOURCE)
+struct stat64
+#else
+struct stat
+#endif
+
+*statbuf)
+
+{
+	int fd = logdToFd(logdes);
+
+#if defined(_LARGEFILE64_SOURCE)
+	return (fstat64(fd, statbuf) == -1) ? errno : 0;
+#else
+	return (fstat(fd, statbuf) == -1) ? errno : 0;
+#endif
+}
+
+/*
  * Return the evlogd socket descriptor for the thread with process ID = pid.
  * Called with logdSocketMutex held and signals blocked.
  */
Index: evlog-1.6.1/user/man/evlconfig.1
===================================================================
--- evlog-1.6.1.orig/user/man/evlconfig.1
+++ evlog-1.6.1/user/man/evlconfig.1
@@ -8,11 +8,10 @@
 .\" For questions regarding the modifications from the
 .\" docbook2man output, contact Dennis Grace at
 .\" <dgrace@us.ibm.com>.
-.TH "EVLCONFIG" "" "14 September 2001" "" ""
+.TH "EVLCONFIG" "" "12 Jul 2006" "" ""
 .SH NAME
 evlconfig \- Configure logging daemon
 .SH SYNOPSIS
-
 \fBevlconfig\fR \fB -l | --list\fR
 
 \fBevlconfig\fR \fB -s | --screen \fR \fB filter \fR| \fBnofilter\fR
@@ -26,19 +25,19 @@ evlconfig \- Configure logging daemon
 \fBevlconfig\fR \fB -L | --lookbacks \fIsize\fB\fR
 
 \fBevlconfig\fR \fB -o | --output\fR  \fB \fIseverity-level \fR| \fBoff\fR
-\fR
+
+\fBevlconfig\fR \fB -n | --newlog\fR \fBno-id\fR | \fBid=\fR\fIstring\fR
 
 .SH "DESCRIPTION"
 .PP
-The \fBevlconfig\fR command lets you change
-the default settings for event logging.  Unless otherwise
-noted, root permission is required to use the following
+The \fBevlconfig\fR command lets you change the default settings for event
+logging.
+Unless otherwise noted, root permission is required to use the following
 \fBevlconfig\fR options.
 .SH "OPTIONS"
 .TP
 \fB-l, --list\fR
-Lists current settings for the
-following:
+Lists current settings for the following:
 .nf
    Discarding of duplicate events, enabled or disabled
    Discarding of duplicates of time interval and count
@@ -49,98 +48,99 @@ following:
 This option is available to all users.
 .TP
 \fB-s, --screen  \fIfilter\fB|\fInofilter\fB\fR
-Specifies a filter name or filter
-expression for screening out events. See the 
-\fIevlquery man page\fR for details. All
-events that match the filter are discarded. All event
-record attributes from the fixed portion of the event
-record can be specified. The default logging behavior
-is that events logged from the kernel
-(log_facility==KERN) or logged by root (effective user
-ID of 'root') are not screened out and
-discarded. Also, by default applications are not
-screened out and discarded (unless attempting to log
-with log_facility==KERN). Issuing the
-\fBevlconfig\fR command with the
-\fB--screen\fR option replaces the existing
-screen, if any, and a filter specification of
-\fInofilter\fR removes the screen.
+Specifies a filter name or filter expression for screening out events.
+See the \fIevlquery man page\fR for details.
+All events that match the filter are discarded.
+All event record attributes from the fixed portion of the event record can
+be specified.
+The default logging behavior is that events logged from the kernel
+(log_facility==KERN) or logged by root (effective user ID of 'root') are
+not screened out and discarded.
+Also, by default applications are not screened out and discarded (unless
+attempting to log with log_facility==KERN).
+Issuing the \fBevlconfig\fR command with the \fB--screen\fR option replaces
+the existing screen, if any, and a filter specification of \fInofilter\fR
+removes the screen.
 .TP
 \fB-i, --interval \fIseconds\fB\fR
-Sets the time interval for discarding
-duplicate events.
-After it has discarded a duplicate event,
-\fBevlogd\fR will wait no more than this many seconds
-before logging a message about the discarded duplicate(s).
-The default interval is three (3)
-seconds. The allowable range is from 1 to 3600 (1
-hour) seconds. If this parameter
-(\fIinterval\fR) is non-zero but
-\fIcount\fR is set to zero, then
-discarding of duplicates will be based strictly on
-time interval, and event \fIcount\fR will
-be ignored. If \fIinterval\fR and
-\fIcount\fR are both equal to
-zero, then logging a message about the discarded duplicates will
-be delayed for as long as possible.
+Sets the time interval for discarding duplicate events.
+After it has discarded a duplicate event, \fBevlogd\fR will wait no more
+than this many seconds before logging a message about the discarded
+duplicate(s).
+The default interval is three (3) seconds.
+The allowable range is from 1 to 3600 (1 hour) seconds.
+If this parameter (\fIinterval\fR) is non-zero but \fIcount\fR is set to
+zero, then discarding of duplicates will be based strictly on time
+interval, and event \fIcount\fR will be ignored.
+If \fIinterval\fR and \fIcount\fR are both equal to zero, then logging a
+message about the discarded duplicates will be delayed for as long as
+possible.
 .TP
 \fB-c, --count \fIevents\fB\fR
-Sets the event count for discarding
-duplicate events.
+Sets the event count for discarding duplicate events.
 \fBevlogd\fR will discard no more than this many duplicates of an event
 before logging a message about the discarded duplicates.
-The default count is 100 events. The
-allowable range is from 1 to 10000. If this parameter
-(\fIcount\fR) is non-zero, but
-\fIinterval\fR is set to zero, then the
-discarding of duplicates will be based strictly on
-event count, and time interval will be ignored. If
-\fIinterval\fR and
-\fIcount\fR are both equal to zero,
-then logging a message about the discarded duplicates will be
-delayed for as long as possible.
+The default count is 100 events.
+The allowable range is from 1 to 10000.
+If this parameter (\fIcount\fR) is non-zero, but \fIinterval\fR is set
+to zero, then the discarding of duplicates will be based strictly on event
+count, and time interval will be ignored.
+If \fIinterval\fR and \fIcount\fR are both equal to zero, then logging a
+message about the discarded duplicates will be delayed for as long as
+possible.
 .TP
 \fB-L, --lookbacks \fIsize\fB\fR
-Sets the number of entries in the lookback buffer,
-used as a cache for discarding of duplicates.
-An incoming event is compared against all events in the
-lookback buffer to determine if it is a duplicate.
-If it is not identical to any of the stored events,
-then it replaces one of the events in the buffer.
+Sets the number of entries in the lookback buffer, used as a cache for
+discarding of duplicates.
+An incoming event is compared against all events in the lookback buffer
+to determine if it is a duplicate.
+If it is not identical to any of the stored events, then it replaces one
+of the events in the buffer.
 The allowable range is from 1 to 10.
 If the value is set to zero then a default size of 5 is used.
 .TP
 \fB-d, --discarddups \fIon\fB|\fIoff\fB\fR
-Enables or disables the discarding of
-events that are being logged in rapid succession. The
-default setting is \fIon\fR. This
-parameter is stored in
-\fI/etc/evlog.d/evlog.conf\fR.
+Enables or disables the discarding of events that are being logged in
+rapid succession.
+The default setting is \fIon\fR.
+This parameter is stored in \fI/etc/evlog.d/evlog.conf\fR.
 .TP
 \fB-o, --output  \fIseverity-level\fB|\fIoff\fB\fR
-Controls displaying of kernel events on the system
-console.  Either specifies the
-severity-level(s) of events to be displayed on the 
-console, or turns displaying completely off.  The 
-default setting is "off".  Valid severity-levels are
-EMERG, ALERT, CRIT, ERR, WARNING, NOTICE, INFO, DEBUG. 
-Specifying a severity-level of CRIT, for example, will
-cause events with severity-level of CRIT and higher 
-(ALERT and EMERG) to be displayed on the system console.
-
-This option utilizes the same system call as the klogd command
-with the -c option.  Events forwarded from printk will not
-be displayed, since they would be duplicates of
-messages already displayed from printk.
-
-For all displayed events, the facility (hex), event type (hex), 
-and format (STRING, PRINTF, BINARY or NODATA)
-will be displayed.  For events with log_format of
-POSIX_LOG_STRING the formatted string will
-also be displayed.  For events with log_format of
-POSIX_LOG_BINARY up to the first 16 bytes
+Controls displaying of kernel events on the system console.
+Either specifies the severity-level(s) of events to be displayed on the
+console, or turns displaying completely off.
+The default setting is "off".
+Valid severity-levels are EMERG, ALERT, CRIT, ERR, WARNING, NOTICE, INFO,
+DEBUG.
+Specifying a severity-level of CRIT, for example, will cause events with
+severity-level of CRIT and higher (ALERT and EMERG) to be displayed on
+the system console.
+
+This option utilizes the same system call as the klogd command with the
+-c option.
+Events forwarded from printk will not be displayed, since they would be
+duplicates of messages already displayed from printk.
+
+For all displayed events, the facility (hex), event type (hex), and
+format (STRING, PRINTF, BINARY or NODATA) will be displayed.
+For events with log_format of POSIX_LOG_STRING the formatted string will
+also be displayed.
+For events with log_format of POSIX_LOG_BINARY up to the first 16 bytes
 of variable data will be displayed in hex.
-
+.TP
+\fB-n, --newlog \fBno-id\fR | \fBid=\fR\fIstring\fR
+Start a new set of log files.
+The existing POSIX log files (i.e. eventlog and privatelog) will be closed,
+new ones created and logging will proceed via the new log files.
+A special message, indicating the switch, will be logged as the last event
+in the old log files and as the first event in the new log files.
+The existing log files will be renamed by appending a timestamp to their
+names.
+
+The format of the timestamp depends on the argument.
+When "no-id" is used the time stamp format is: __YYYY_MMDD_hhmmss__usec.
+When "id=string" is used the time stamp format is:
+_string__YYYY_MMDD_hhmmss__usec.
 .SH "EXAMPLES"
 .PP
 \fBExample 1.\fR
@@ -160,9 +160,9 @@ displays the following:
   Console display level = CRIT                
 .fi
 .PP
-The event screen in this example indicates to
-log DEBUG events only from root. All other DEBUG
-events are discarded.
+The event screen in this example indicates to log DEBUG events only from
+root.
+All other DEBUG events are discarded.
 
 
 \fBExample 2.\fR
Index: evlog-1.6.1/user/man/evlconfig.1.in
===================================================================
--- evlog-1.6.1.orig/user/man/evlconfig.1.in
+++ evlog-1.6.1/user/man/evlconfig.1.in
@@ -8,7 +8,7 @@
 .\" For questions regarding the modifications from the
 .\" docbook2man output, contact Dennis Grace at
 .\" <dgrace@us.ibm.com>.
-.TH "EVLCONFIG" "" "14 September 2001" "" ""
+.TH "EVLCONFIG" "" "12 Jul 2006" "" ""
 .SH NAME
 evlconfig \- Configure logging daemon
 .SH SYNOPSIS
@@ -26,13 +26,14 @@ evlconfig \- Configure logging daemon
 \fBevlconfig\fR \fB -L | --lookbacks \fIsize\fB\fR
 
 \fBevlconfig\fR \fB -o | --output\fR  \fB \fIseverity-level \fR| \fBoff\fR
-\fR
+
+\fBevlconfig\fR \fB -n | --newlog\fR \fBno-id\fR | \fBid=\fR\fIstring\fR
 
 .SH "DESCRIPTION"
 .PP
-The \fBevlconfig\fR command lets you change
-the default settings for event logging.  Unless otherwise
-noted, root permission is required to use the following
+The \fBevlconfig\fR command lets you change the default settings for event
+logging.
+Unless otherwise noted, root permission is required to use the following
 \fBevlconfig\fR options.
 .SH "OPTIONS"
 .TP
@@ -49,98 +50,99 @@ following:
 This option is available to all users.
 .TP
 \fB-s, --screen  \fIfilter\fB|\fInofilter\fB\fR
-Specifies a filter name or filter
-expression for screening out events. See the 
-\fIevlquery man page\fR for details. All
-events that match the filter are discarded. All event
-record attributes from the fixed portion of the event
-record can be specified. The default logging behavior
-is that events logged from the kernel
-(log_facility==KERN) or logged by root (effective user
-ID of 'root') are not screened out and
-discarded. Also, by default applications are not
-screened out and discarded (unless attempting to log
-with log_facility==KERN). Issuing the
-\fBevlconfig\fR command with the
-\fB--screen\fR option replaces the existing
-screen, if any, and a filter specification of
+Specifies a filter name or filter expression for screening out events.
+See the \fIevlquery man page\fR for details.
+All events that match the filter are discarded.
+All event record attributes from the fixed portion of the event record
+can be specified.
+The default logging behavior is that events logged from the kernel
+(log_facility==KERN) or logged by root (effective user ID of 'root') are
+not screened out and discarded.
+Also, by default applications are not screened out and discarded (unless
+attempting to log with log_facility==KERN).
+Issuing the \fBevlconfig\fR command with the \fB--screen\fR option
+replaces the existing screen, if any, and a filter specification of
 \fInofilter\fR removes the screen.
 .TP
 \fB-i, --interval \fIseconds\fB\fR
-Sets the time interval for discarding
-duplicate events.
-After it has discarded a duplicate event,
-\fBevlogd\fR will wait no more than this many seconds
-before logging a message about the discarded duplicate(s).
-The default interval is three (3)
-seconds. The allowable range is from 1 to 3600 (1
-hour) seconds. If this parameter
-(\fIinterval\fR) is non-zero but
-\fIcount\fR is set to zero, then
-discarding of duplicates will be based strictly on
-time interval, and event \fIcount\fR will
-be ignored. If \fIinterval\fR and
-\fIcount\fR are both equal to
-zero, then logging a message about the discarded duplicates will
-be delayed for as long as possible.
+Sets the time interval for discarding duplicate events.
+After it has discarded a duplicate event, \fBevlogd\fR will wait no more
+than this many seconds before logging a message about the discarded
+duplicate(s).
+The default interval is three (3) seconds.
+The allowable range is from 1 to 3600 (1 hour) seconds.
+If this parameter (\fIinterval\fR) is non-zero but \fIcount\fR is set to
+zero, then discarding of duplicates will be based strictly on time
+interval, and event \fIcount\fR will be ignored.
+If \fIinterval\fR and \fIcount\fR are both equal to zero, then logging a
+message about the discarded duplicates will be delayed for as long as
+possible.
 .TP
 \fB-c, --count \fIevents\fB\fR
-Sets the event count for discarding
-duplicate events.
+Sets the event count for discarding duplicate events.
 \fBevlogd\fR will discard no more than this many duplicates of an event
 before logging a message about the discarded duplicates.
-The default count is 100 events. The
-allowable range is from 1 to 10000. If this parameter
-(\fIcount\fR) is non-zero, but
-\fIinterval\fR is set to zero, then the
-discarding of duplicates will be based strictly on
-event count, and time interval will be ignored. If
-\fIinterval\fR and
-\fIcount\fR are both equal to zero,
-then logging a message about the discarded duplicates will be
-delayed for as long as possible.
+The default count is 100 events.
+The allowable range is from 1 to 10000.
+If this parameter (\fIcount\fR) is non-zero, but \fIinterval\fR is set
+to zero, then the discarding of duplicates will be based strictly on
+event count, and time interval will be ignored.
+If \fIinterval\fR and \fIcount\fR are both equal to zero, then logging a
+message about the discarded duplicates will be delayed for as long as
+possible.
 .TP
 \fB-L, --lookbacks \fIsize\fB\fR
-Sets the number of entries in the lookback buffer,
-used as a cache for discarding of duplicates.
-An incoming event is compared against all events in the
-lookback buffer to determine if it is a duplicate.
-If it is not identical to any of the stored events,
-then it replaces one of the events in the buffer.
+Sets the number of entries in the lookback buffer, used as a cache for
+discarding of duplicates.
+An incoming event is compared against all events in the lookback buffer
+to determine if it is a duplicate.
+If it is not identical to any of the stored events, then it replaces one
+of the events in the buffer.
 The allowable range is from 1 to 10.
 If the value is set to zero then a default size of 5 is used.
 .TP
 \fB-d, --discarddups \fIon\fB|\fIoff\fB\fR
-Enables or disables the discarding of
-events that are being logged in rapid succession. The
-default setting is \fIon\fR. This
-parameter is stored in
-\fI/etc/evlog.d/evlog.conf\fR.
+Enables or disables the discarding of events that are being logged in
+rapid succession.
+The default setting is \fIon\fR.
+This parameter is stored in \fI/etc/evlog.d/evlog.conf\fR.
 .TP
 \fB-o, --output  \fIseverity-level\fB|\fIoff\fB\fR
-Controls displaying of kernel events on the system
-console.  Either specifies the
-severity-level(s) of events to be displayed on the 
-console, or turns displaying completely off.  The 
-default setting is "off".  Valid severity-levels are
-EMERG, ALERT, CRIT, ERR, WARNING, NOTICE, INFO, DEBUG. 
-Specifying a severity-level of CRIT, for example, will
-cause events with severity-level of CRIT and higher 
-(ALERT and EMERG) to be displayed on the system console.
-
-This option utilizes the same system call as the klogd command
-with the -c option.  Events forwarded from printk will not
-be displayed, since they would be duplicates of
-messages already displayed from printk.
-
-For all displayed events, the facility (hex), event type (hex), 
-and format (STRING, PRINTF, BINARY or NODATA)
-will be displayed.  For events with log_format of
-POSIX_LOG_STRING the formatted string will
-also be displayed.  For events with log_format of
-POSIX_LOG_BINARY up to the first 16 bytes
+Controls displaying of kernel events on the system console.
+Either specifies the severity-level(s) of events to be displayed on the
+console, or turns displaying completely off.
+The default setting is "off".
+Valid severity-levels are EMERG, ALERT, CRIT, ERR, WARNING, NOTICE, INFO,
+DEBUG.
+Specifying a severity-level of CRIT, for example, will cause events with
+severity-level of CRIT and higher (ALERT and EMERG) to be displayed on
+the system console.
+
+This option utilizes the same system call as the klogd command with the
+-c option.
+Events forwarded from printk will not be displayed, since they would be
+duplicates of messages already displayed from printk.
+
+For all displayed events, the facility (hex), event type (hex), and
+format (STRING, PRINTF, BINARY or NODATA) will be displayed.
+For events with log_format of POSIX_LOG_STRING the formatted string will
+also be displayed.
+For events with log_format of POSIX_LOG_BINARY up to the first 16 bytes
 of variable data will be displayed in hex.
-
+.TP
+\fB-n, --newlog \fBno-id\fR | \fBid=\fR\fIstring\fR
+Start a new set of log files.
+The existing POSIX log files (i.e. eventlog and privatelog) will be closed,
+new ones created and logging will proceed via the new log files.
+A special message, indicating the switch, will be logged as the last event
+in the old log files and as the first event in the new log files.
+The existing log files will be renamed by appending a timestamp to their
+names.
+
+The format of the timestamp depends on the argument.
+When "no-id" is used the time stamp format is: __YYYY_MMDD_hhmmss__usec.
+When "id=string" is used the time stamp format is:
+_string__YYYY_MMDD_hhmmss__usec.
 .SH "EXAMPLES"
 .PP
 \fBExample 1.\fR
@@ -160,9 +162,9 @@ displays the following:
   Console display level = CRIT                
 .fi
 .PP
-The event screen in this example indicates to
-log DEBUG events only from root. All other DEBUG
-events are discarded.
+The event screen in this example indicates to log DEBUG events only from
+root.
+All other DEBUG events are discarded.
 
 
 \fBExample 2.\fR
Index: evlog-1.6.1/user/man/evlog.1
===================================================================
--- evlog-1.6.1.orig/user/man/evlog.1
+++ evlog-1.6.1/user/man/evlog.1
@@ -7,34 +7,35 @@
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
 .\" For questions regarding the content of this manpage,
 .\" contact <lkessler@users.sourceforge.net>.
-.TH "EVLOG" "" "6 December 2002" ""Introduction
+.TH "EVLOG" "" "12 Jul 2006" ""Introduction
 .SH NAME
 Introduction to Event Logging
 .SH "DESCRIPTION"
 .PP
 Event logging implements the proposed POSIX Standard - Event Logging
-[C Language]. In this implementation, event records are stored in
-binary format. Binary records give you the ability to capture
-sophisticated event records but they require you to use specialized
-commands to create, view and maintain event logs and event
-records. This manpage describes the set of specialized commands and
-services that support event logging.
+[C Language].
+In this implementation, event records are stored in binary format.
+Binary records give you the ability to capture sophisticated event
+records but they require you to use specialized commands to create,
+view and maintain event logs and event records.
+This manpage describes the set of specialized commands and services
+that support event logging.
 .PP 
 By default, event logging creates two logs:
 .TP
 \fB/var/evlog/eventlog\fR
-\fIEventlog\fR is the primary system log. It contains all event
-records that are publically viewable.
+\fIEventlog\fR is the primary system log.
+It contains all event records that are publically viewable.
 .TP
 \fB/var/evlog/privatelog\fR
 \fIPrivatelog\fR is a secondary system log that contains records you
-generally don't want to be publically viewable.  By default, only
-event records with facility of \fIAUTHPRIV\fR are written to this
-log.  However, events from other facilities can also be written to
-this log, as specified with the \fIevlfacility\fR command.
-An example of private
-records are those associated with port connections for services
-running on a system.
+generally don't want to be publically viewable.
+By default, only event records with facility of \fIAUTHPRIV\fR are
+written to this log.
+However, events from other facilities can also be written to this log,
+as specified with the \fIevlfacility\fR command.
+An example of private records are those associated with port connections
+for services running on a system.
 .PP
 In addition to letting you create and maintain logs, event logging
 provides you the ability to be notified when events of interest to you
@@ -43,19 +44,20 @@ automatically in response to those event
 .SH "COMMANDS"
 .TP
 \fBevlview(1)\fR
-Lets you display event records from a POSIX-standard event
-log. \fIevlview\fR gives you many options for selecting what records
-you view and for designating what format to use in displaying those
-records.
+Lets you display event records from a POSIX-standard event log.
+\fIevlview\fR gives you many options for selecting what records you view
+and for designating what format to use in displaying those records.
 .TP
 \fBevlfacility(1)\fR
 Lets you register and list facilities defined for a system. 
 Facilities are simply the components of a system that issue event
-records.  Facilities include the kernel, device drivers, services,
-such as mail, cron and ftp, and user applications.  Event log
-facilities include, but are not limited to, facilities defined for
-syslog. \fIevlfacility\fR ensures that facilities you register are
-uniquely identified across systems.
+records.
+Facilities include the kernel, device drivers, services, such as mail,
+cron and ftp, and user applications.
+Event log facilities include, but are not limited to, facilities defined
+for syslog.
+\fIevlfacility\fR ensures that facilities you register are uniquely
+identified across systems.
 .TP
 \fBevlnotify(1)\fR
 Lets you register a description of those events for which you want to
@@ -66,8 +68,9 @@ have executed on your behalf when such e
 Lets you change the configurable settings for event logging.
 Configurable settings include the count and time interval for removing
 duplicate records, a severity level to indicate which (if any) events
-you want displayed to the system console, and filters for screening
-out events you don't want written to the system log.
+you want displayed to the system console, filters for screening
+out events you don't want written to the system log and the creation
+of a new set of log files (public and private).
 .TP
 \fBevltc(1)\fR
 Compiles formatting templates containing C-like structures used for 
@@ -75,42 +78,41 @@ parsing and displaying event data, for e
 command.  
 .TP
 \fBevlogmgr(1)\fR
-Lets you perform log management on the event log, on the private log,
-or optionally, on a log file that you  specify.  You specify which
-events are to be deleted. The space freed by deleted events is
-reused for undeleted events (a process referred to as compaction) and
-the log file is truncated, thus reducing its overall size.
+Lets you perform log management on a log file that you specify.
+You specify which events are to be deleted.
+The space freed by deleted events is reused for undeleted events (a
+process referred to as compaction) and the log file is truncated,
+thus reducing its overall size.
 .TP
 \fBevlsend(1)\fR
 Lets you send event records from scripts or directly from a command 
 line.
 .SH "QUERIES"
-The commands \fIevlview\fR, \fIevlnotify\fR, \fIevlconfig\fR,
-and \fIevlogmgr\fR let you specify a query or filter to describe
-the kinds of events in which you are interested.  For details of how
-to specify queries, see \fBevlquery(1)\fR.
+The commands \fIevlview\fR, \fIevlnotify\fR, \fIevlconfig\fR, and
+\fIevlogmgr\fR let you specify a query or filter to describe the kinds
+of events in which you are interested.
+For details of how to specify queries, see \fBevlquery(1)\fR.
 .SH "DAEMONS"
 .TP
 \fB/sbin/evlogd\fR
-The event log daemon reads event records from facilities running in
-the kernel and in user space and writes those records to the
-appropriate local POSIX-standard log file.  Additionally, plug-ins can be
-provided that register with evlogd to receive the event stream
-and provide alternative methods of processing and logging the events.
+The event log daemon reads event records from facilities running in the
+kernel and in user space and writes those records to the appropriate
+local POSIX-standard log file.
+Additionally, plug-ins can be provided that register with evlogd to
+receive the event stream and provide alternative methods of processing
+and logging the events.
 
 2 plug-ins are provided with the event logging package:   
-the \fB udp_rmtlog_be\fR plugin and \fBtcp_rmtlog_be\fR 
-plugin which forward
-events to a centralized event consolidation host, using UDP and
+the \fB udp_rmtlog_be\fR plugin and \fBtcp_rmtlog_be\fR plugin which
+forward events to a centralized event consolidation host, using UDP and
 TCP, respectively.
 .TP
 \fB/sbin/evlogrmtd\fR 
 The remote event daemon receives event records from other hosts on the
 network that are transmitting with the \fB udp_rmtlog_be\fR or
-\fBtcp_rmtlog_be\fR plugin, and
-if the source host is listed in the \fI/etc/evlog.d/evlhosts\fR file,
-passes the event record to the evlogd.  Otherwise, the event record is
-rejected and discarded by the evlogrmtd. 
+\fBtcp_rmtlog_be\fR plugin, and if the source host is listed in the
+\fI/etc/evlog.d/evlhosts\fR file, passes the event record to the evlogd.
+Otherwise, the event record is rejected and discarded by the evlogrmtd.
 .TP
 \fB/sbin/evlnotifyd\fR
 The event notification daemon accepts notification requests from
Index: evlog-1.6.1/user/man/evlog.1.in
===================================================================
--- evlog-1.6.1.orig/user/man/evlog.1.in
+++ evlog-1.6.1/user/man/evlog.1.in
@@ -7,34 +7,35 @@
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
 .\" For questions regarding the content of this manpage,
 .\" contact <lkessler@users.sourceforge.net>.
-.TH "EVLOG" "" "6 December 2002" ""Introduction
+.TH "EVLOG" "" "12 Jul 2006" ""Introduction
 .SH NAME
 Introduction to Event Logging
 .SH "DESCRIPTION"
 .PP
 Event logging implements the proposed POSIX Standard - Event Logging
-[C Language]. In this implementation, event records are stored in
-binary format. Binary records give you the ability to capture
-sophisticated event records but they require you to use specialized
-commands to create, view and maintain event logs and event
-records. This manpage describes the set of specialized commands and
-services that support event logging.
+[C Language].
+In this implementation, event records are stored in binary format.
+Binary records give you the ability to capture sophisticated event
+records but they require you to use specialized commands to create,
+view and maintain event logs and event records.
+This manpage describes the set of specialized commands and services
+that support event logging.
 .PP 
 By default, event logging creates two logs:
 .TP
 \fB@localstatedir@/eventlog\fR
-\fIEventlog\fR is the primary system log. It contains all event
-records that are publically viewable.
+\fIEventlog\fR is the primary system log.
+It contains all event records that are publically viewable.
 .TP
 \fB@localstatedir@/privatelog\fR
 \fIPrivatelog\fR is a secondary system log that contains records you
-generally don't want to be publically viewable.  By default, only
-event records with facility of \fIAUTHPRIV\fR are written to this
-log.  However, events from other facilities can also be written to
-this log, as specified with the \fIevlfacility\fR command.
-An example of private
-records are those associated with port connections for services
-running on a system.
+generally don't want to be publically viewable.
+By default, only event records with facility of \fIAUTHPRIV\fR are
+written to this log.
+However, events from other facilities can also be written to this log,
+as specified with the \fIevlfacility\fR command.
+An example of private records are those associated with port connections
+for services running on a system.
 .PP
 In addition to letting you create and maintain logs, event logging
 provides you the ability to be notified when events of interest to you
@@ -43,19 +44,20 @@ automatically in response to those event
 .SH "COMMANDS"
 .TP
 \fBevlview(1)\fR
-Lets you display event records from a POSIX-standard event
-log. \fIevlview\fR gives you many options for selecting what records
-you view and for designating what format to use in displaying those
-records.
+Lets you display event records from a POSIX-standard event log.
+\fIevlview\fR gives you many options for selecting what records you view
+and for designating what format to use in displaying those records.
 .TP
 \fBevlfacility(1)\fR
 Lets you register and list facilities defined for a system. 
 Facilities are simply the components of a system that issue event
-records.  Facilities include the kernel, device drivers, services,
-such as mail, cron and ftp, and user applications.  Event log
-facilities include, but are not limited to, facilities defined for
-syslog. \fIevlfacility\fR ensures that facilities you register are
-uniquely identified across systems.
+records.
+Facilities include the kernel, device drivers, services, such as mail,
+cron and ftp, and user applications.
+Event log facilities include, but are not limited to, facilities defined
+for syslog.
+\fIevlfacility\fR ensures that facilities you register are uniquely
+identified across systems.
 .TP
 \fBevlnotify(1)\fR
 Lets you register a description of those events for which you want to
@@ -66,8 +68,9 @@ have executed on your behalf when such e
 Lets you change the configurable settings for event logging.
 Configurable settings include the count and time interval for removing
 duplicate records, a severity level to indicate which (if any) events
-you want displayed to the system console, and filters for screening
-out events you don't want written to the system log.
+you want displayed to the system console, filters for screening
+out events you don't want written to the system log and the creation
+of a new set of log files (public and private).
 .TP
 \fBevltc(1)\fR
 Compiles formatting templates containing C-like structures used for 
@@ -75,42 +78,41 @@ parsing and displaying event data, for e
 command.  
 .TP
 \fBevlogmgr(1)\fR
-Lets you perform log management on the event log, on the private log,
-or optionally, on a log file that you  specify.  You specify which
-events are to be deleted. The space freed by deleted events is
-reused for undeleted events (a process referred to as compaction) and
-the log file is truncated, thus reducing its overall size.
+Lets you perform log management on a log file that you specify.
+You specify which events are to be deleted.
+The space freed by deleted events is reused for undeleted events (a
+process referred to as compaction) and the log file is truncated,
+thus reducing its overall size.
 .TP
 \fBevlsend(1)\fR
 Lets you send event records from scripts or directly from a command 
 line.
 .SH "QUERIES"
-The commands \fIevlview\fR, \fIevlnotify\fR, \fIevlconfig\fR,
-and \fIevlogmgr\fR let you specify a query or filter to describe
-the kinds of events in which you are interested.  For details of how
-to specify queries, see \fBevlquery(1)\fR.
+The commands \fIevlview\fR, \fIevlnotify\fR, \fIevlconfig\fR, and
+\fIevlogmgr\fR let you specify a query or filter to describe the kinds
+of events in which you are interested.
+For details of how to specify queries, see \fBevlquery(1)\fR.
 .SH "DAEMONS"
 .TP
 \fB/sbin/evlogd\fR
-The event log daemon reads event records from facilities running in
-the kernel and in user space and writes those records to the
-appropriate local POSIX-standard log file.  Additionally, plug-ins can be
-provided that register with evlogd to receive the event stream
-and provide alternative methods of processing and logging the events.
+The event log daemon reads event records from facilities running in the
+kernel and in user space and writes those records to the appropriate
+local POSIX-standard log file.
+Additionally, plug-ins can be provided that register with evlogd to
+receive the event stream and provide alternative methods of processing
+and logging the events.
 
 2 plug-ins are provided with the event logging package:   
-the \fB udp_rmtlog_be\fR plugin and \fBtcp_rmtlog_be\fR 
-plugin which forward
-events to a centralized event consolidation host, using UDP and
+the \fB udp_rmtlog_be\fR plugin and \fBtcp_rmtlog_be\fR plugin which
+forward events to a centralized event consolidation host, using UDP and
 TCP, respectively.
 .TP
 \fB/sbin/evlogrmtd\fR 
 The remote event daemon receives event records from other hosts on the
 network that are transmitting with the \fB udp_rmtlog_be\fR or
-\fBtcp_rmtlog_be\fR plugin, and
-if the source host is listed in the \fI/etc/evlog.d/evlhosts\fR file,
-passes the event record to the evlogd.  Otherwise, the event record is
-rejected and discarded by the evlogrmtd. 
+\fBtcp_rmtlog_be\fR plugin, and if the source host is listed in the
+\fI/etc/evlog.d/evlhosts\fR file, passes the event record to the evlogd.
+Otherwise, the event record is rejected and discarded by the evlogrmtd.
 .TP
 \fB/sbin/evlnotifyd\fR
 The event notification daemon accepts notification requests from
Index: evlog-1.6.1/user/man/evlogmgr.1
===================================================================
--- evlog-1.6.1.orig/user/man/evlogmgr.1
+++ evlog-1.6.1/user/man/evlogmgr.1
@@ -17,100 +17,96 @@
 .el .ne 3
 .IP "\\$1" \\$2
 ..
-.TH "evlogmgr"  "" "" ""
+.TH "EVLOGMGR" "1" "12 Jul 2006" "" ""
 .SH NAME
 evlogmgr \- Event log manager
 .SH "SYNOPSIS"
-\fBevlogmgr\fR   \fB-c\fR | \fB--compact  \fIfilter\fR \fR 
+\fBevlogmgr\fR \fB-c\fR | \fB--compact  \fIfilter\fR \fR
  [ \fB-F\fR | \fB--force\fR ] [ \fB-C\fR | \fB--compr-bak\fR ] 
- [[\fB \fB-p\fR | \fB--private\fR \fR ] | [\fB \fB-l\fR | \fB--log  \fIsrcfile\fR \fR \fR]]
+ \fB-l\fR | \fB--log\fR \fIsrcfile\fR
 
-\fBevlogmgr\fR   \fB-f\fR | \fB--fix\fR  
- [[\fB \fB-p\fR | \fB--private\fR \fR ] | [\fB \fB-l\fR | \fB--log  \fIsrcfile\fR \fR \fR]]
+\fBevlogmgr\fR \fB-f\fR | \fB--fix\fR \fB-l\fR | \fB--log\fR \fIsrcfile\fR
 
-\fBevlogmgr\fR   \fB-s\fR | \fB--show-status  \fIfilter\fR \fR  
- [[\fB \fB-p\fR | \fB--private\fR \fR ] | [\fB \fB-l\fR | \fB--log  \fIsrcfile\fR \fR \fR]]
+\fBevlogmgr\fR \fB-s\fR | \fB--show-status  \fIfilter\fR \fR \fB-l\fR | \fB--log\fR \fIsrcfile\fR
 .SH "DESCRIPTION"
-
 .PP
-The \fBevlogmgr\fR command performs log management on the event log, on the private log, or optionally, on a log file that you specify. You also specify which events are to be deleted. The space freed by deleted events is reused for undeleted events (a process referred to as compaction) and the log file is truncated, thus reducing its overall size.
-
+The \fBevlogmgr\fR command performs log management on a non-active event
+log file \fIsrcfile\fR.
+You also specify which events are to be deleted.
+The space freed by deleted events is released when log file is truncated,
+thus reducing its overall size.
 .PP
 You must have root permission to use this command.
-
+.PP
+Log management cannot be performed on the active log files,
+\fI/var/evlog/eventlog\fR and \fI/var/evlog/privatelog\fR.
 .SH "OPTIONS"
-
 .TP
--\fBc\fR, --\fBcompact\fR \fIfilter\fR 
-Deletes event records in the event log matching the specified filter, fills space freed by deleting the event records (by moving later records into the free space), and then truncates the log thus establishing a new write offset for new events. The sequential order of events in the event log is maintained during this process and the record ids of the remaining event records are left unchanged. See the \fBevlquery\fR man page for more information about the \fIfilter\fR.
-
-Before the compaction process begins, a backup copy of the log file is created if space is available. Following successful compaction, the backup copy is deleted. If the \fBevlogmgr\fR command is issued from the command line, and the user types Ctrl-C, then the active log file is restored from the backup copy. In the event that the system reboots before compaction completes, the active log file is restored from the backup copy (after reboot).
-
-Unless the --\fBprivate\fR or --\fBlog\fR options are used, log management is performed on \fI/var/evlog/eventlog\fR.
-
-The --\fBforce\fR option should only be used as a last resort. If space is not available to create a backup (compressed or uncompressed), then this option forces compaction to occur without first creating a backup of the log file. If compaction does not complete successfully, then the \fBevlogmgr\fR command with the --\fBfix\fR option (see below) might be able to restore the log file to a usable state.
-
-The --\fBcompr-bak\fR option specifies that the backup log file created prior to compacting the original log file should be compressed. This option will take longer, but limited space might require its use.
-
-The --\fBprivate\fR option specifies that compaction should be performed on \fI/var/evlog/privatelog\fR. This option is not valid in combination with the --\fBlog\fR option.
-
-The --\fBlog\fR option specifies an alternate log file, \fIsrcfile\fR, to be compacted. This option is not valid in combination with the --\fBprivate\fR option.
+-\fBl\fR, --\fBlog\fR \fIsrcfile\fR
+Specifies the log file that management is to be performed on.
 
+This option is manadory.
+.TP
+-\fBc\fR, --\fBcompact\fR \fIfilter\fR
+Deletes event records in the event log matching the specified filter,
+fills space freed by deleting the event records (by moving later records
+into the free space), and then truncates the log.
+The sequential order of events in the event log is maintained during this
+process and the record IDs of the remaining event records are left
+unchanged.
+See the \fBevlquery\fR man page for more information about the
+\fIfilter\fR.
+
+Before the compaction process begins, a backup copy of the log file is
+created if space is available.
+Following successful compaction, the backup copy is deleted.
+If the \fBevlogmgr\fR command is issued from the command line, and the
+user types Ctrl-C, then the active log file is restored from the backup
+copy.
+
+The --\fBforce\fR option should only be used as a last resort.
+If space is not available to create a backup (compressed or uncompressed),
+then this option forces compaction to occur without first creating a
+backup of the log file.
+If compaction does not complete successfully, then the \fBevlogmgr\fR
+command with the --\fBfix\fR option (see below) might be able to restore
+the log file to a usable state.
+
+The --\fBcompr-bak\fR option specifies that the backup log file created
+prior to compacting the original log file should be compressed.
+This option will take longer, but limited space might require its use.
 .TP
 -\fBf\fR, --\fBfix\fR 
-This option is used to repair a corrupted log file, and is required only in cases where the --\fBforce\fR option was used and the log management tasks terminated before completion.
-
-Each record in the event log is validated, and any records that are deemed invalid are deleted and replaced by valid records in the log. The command reports the total number of bytes deleted.
+This option is used to repair a corrupted log file, and is required only
+in cases where the --\fBforce\fR option was used and the log management
+tasks terminated before completion.
+
+Each record in the event log is validated, and any records that are deemed
+invalid are deleted and replaced by valid records in the log.
+The command reports the total number of bytes deleted.
 
-Some of the error messages that will indicate the need to repair the log include:
+Some of the error messages that will indicate the need to repair the log
+include:
 
 \(bu Input/output error (from evlview)
 .Pp
 
-\(bu Failed to count record for deletion 
-    (from evlogmgr -s)
+\(bu Failed to count record for deletion (from evlogmgr -s)
 .Pp
 
-\(bu Failed to compact log  (from evlogmgr -c)
+\(bu Failed to compact log (from evlogmgr -c)
 .Pp
-
-Unless the --\fBprivate\fR or --\fBlog\fR options are used, repair is performed on \fI/var/evlog/eventlog\fR.
-
-The --\fBprivate\fR option specifies that repair should be performed on \fI/var/evlog/privatelog\fR. This option is not valid in combination with the --\fBlog\fR option.
-
-The --\fBlog\fR option specifies an alternate log file, \fIsrcfile\fR, to be repaired. This option is not valid in combination with the --\fBprivate\fR option.
-
 .TP
 -\fBs\fR, --\fBshow-status\fR \fIfilter\fR 
-Shows how many records in the event log match the \fIfilter\fR, and shows the total number of records in the log. See the \fBevlquery\fR man page for more information about the \fIfilter\fR.
-
-Unless the --\fBprivate\fR or --\fBlog\fR options are used, status is shown for \fI/var/evlog/eventlog\fR.
-
-The --\fBprivate\fR option specifies that status should be shown for \fI/var/evlog/privatelog\fR. This option is not valid in combination with the --\fBlog\fR option.
-
-The --\fBlog\fR option specifies that status should be shown for an alternate log file, \fIsrcfile\fR. This option is not valid in combination with the --\fBprivate\fR option.
-
+Shows how many records in the event log match the \fIfilter\fR, and shows
+the total number of records in the log.
+See the \fBevlquery\fR man page for more information about the \fIfilter\fR.
 .SH "EXAMPLES"
-
 .TP
 Example 1
-Run \fBevlogmgr\fR -\fBc\fR from a cron job. See "man 5 crontab" for more details.
-
-# Daily at 2 AM remove recds older than 30 days
-
-0 2 * * * root /sbin/evlogmgr -c 'age > "30d"'
-
-      
-
-# Daily at 1 AM remove recds w/ sev=DEBUG
-
-0 1 * * * root /sbin/evlogmgr -c "severity=DEBUG"
-
-.TP
-Example 2
 Issuing the following command:
 
-   evlogmgr -c 'severity=DEBUG' -C 
+   evlogmgr -c 'severity=DEBUG' -C --log srcfile
    
 might result in the following events being appended to the log:
 
@@ -124,10 +120,10 @@ severity=NOTICE, uid=root, gid=root, pid
 time=Thu 09 May 2002 12:59:09 PM PDT, flags=0x0, thread=0x400, processor=0
 Log compaction on /var/evlog/eventlog ended. 48 events were removed. 
 .TP
-Example 3
+Example 2
 Issuing the following command:
 
-   evlogmgr -s 'severity=DEBUG'
+   evlogmgr -s 'severity=DEBUG' --log srcfile
  
 might display the following:
 
@@ -135,25 +131,16 @@ might display the following:
    Number of records matching the filter is 48.
    Log file size would be reduced by 5.00 kbytes
 .TP
-Example 4
+Example 3
 Issuing the following command:
 
-   evlogmgr --fix
+   evlogmgr --fix --log srcfile
   
 might display the following:
 
   Found a corrupted event record. Trying to resync with next good record...
   Log repair finished, problem fixed.  Discarded 6 bytes. 
-.SH "FILES"
-
-.TP
-\fI/var/evlog/eventlog\fR
-standard event log
-
-.TP
-\fI/var/evlog/privatelog\fR
-private event log
-
 .SH "SEE ALSO"
 \fIevlquery man page\fR    Filter expression syntax rules
-
+\fIevlconfig man page\fR   New log creation
+\fIevlview man page\fR	   Log file display
Index: evlog-1.6.1/user/man/evlogmgr.1.in
===================================================================
--- evlog-1.6.1.orig/user/man/evlogmgr.1.in
+++ evlog-1.6.1/user/man/evlogmgr.1.in
@@ -17,117 +17,112 @@
 .el .ne 3
 .IP "\\$1" \\$2
 ..
-.TH "evlogmgr"  "" "" ""
+.TH "EVLOGMGR" "1" "12 Jul 2006" "" ""
 .SH NAME
 evlogmgr \- Event log manager
 .SH "SYNOPSIS"
-\fBevlogmgr\fR   \fB-c\fR | \fB--compact  \fIfilter\fR \fR 
+\fBevlogmgr\fR \fB-c\fR | \fB--compact  \fIfilter\fR \fR
  [ \fB-F\fR | \fB--force\fR ] [ \fB-C\fR | \fB--compr-bak\fR ] 
- [[\fB \fB-p\fR | \fB--private\fR \fR ] | [\fB \fB-l\fR | \fB--log  \fIsrcfile\fR \fR \fR]]
+ \fB-l\fR | \fB--log\fR \fIsrcfile\fR
 
-\fBevlogmgr\fR   \fB-f\fR | \fB--fix\fR  
- [[\fB \fB-p\fR | \fB--private\fR \fR ] | [\fB \fB-l\fR | \fB--log  \fIsrcfile\fR \fR \fR]]
+\fBevlogmgr\fR \fB-f\fR | \fB--fix\fR \fB-l\fR | \fB--log\fR \fIsrcfile\fR
 
-\fBevlogmgr\fR   \fB-s\fR | \fB--show-status  \fIfilter\fR \fR  
- [[\fB \fB-p\fR | \fB--private\fR \fR ] | [\fB \fB-l\fR | \fB--log  \fIsrcfile\fR \fR \fR]]
+\fBevlogmgr\fR \fB-s\fR | \fB--show-status  \fIfilter\fR \fR \fB-l\fR | \fB--log\fR \fIsrcfile\fR
 .SH "DESCRIPTION"
-
-.PP
-The \fBevlogmgr\fR command performs log management on the event log, on the private log, or optionally, on a log file that you specify. You also specify which events are to be deleted. The space freed by deleted events is reused for undeleted events (a process referred to as compaction) and the log file is truncated, thus reducing its overall size.
-
+The \fBevlogmgr\fR command performs log management on a non-active event
+log file \fIsrcfile\fR.
+You also specify which events are to be deleted.
+The space freed by deleted events is released when log file is truncated,
+thus reducing its overall size.
 .PP
 You must have root permission to use this command.
-
+.PP
+Log management cannot be performed on the active log files,
+\fI/var/evlog/eventlog\fR and \fI/var/evlog/privatelog\fR.
 .SH "OPTIONS"
+.TP
+-\fBl\fR, --\fBlog\fR \fIsrcfile\fR
+Specifies the log file that management is to be performed on.
 
+This option is manadory.
 .TP
 -\fBc\fR, --\fBcompact\fR \fIfilter\fR 
-Deletes event records in the event log matching the specified filter, fills space freed by deleting the event records (by moving later records into the free space), and then truncates the log thus establishing a new write offset for new events. The sequential order of events in the event log is maintained during this process and the record ids of the remaining event records are left unchanged. See the \fBevlquery\fR man page for more information about the \fIfilter\fR.
-
-Before the compaction process begins, a backup copy of the log file is created if space is available. Following successful compaction, the backup copy is deleted. If the \fBevlogmgr\fR command is issued from the command line, and the user types Ctrl-C, then the active log file is restored from the backup copy. In the event that the system reboots before compaction completes, the active log file is restored from the backup copy (after reboot).
-
-Unless the --\fBprivate\fR or --\fBlog\fR options are used, log management is performed on \fI@localstatedir@/eventlog\fR.
-
-The --\fBforce\fR option should only be used as a last resort. If space is not available to create a backup (compressed or uncompressed), then this option forces compaction to occur without first creating a backup of the log file. If compaction does not complete successfully, then the \fBevlogmgr\fR command with the --\fBfix\fR option (see below) might be able to restore the log file to a usable state.
-
-The --\fBcompr-bak\fR option specifies that the backup log file created prior to compacting the original log file should be compressed. This option will take longer, but limited space might require its use.
-
-The --\fBprivate\fR option specifies that compaction should be performed on \fI@localstatedir@/privatelog\fR. This option is not valid in combination with the --\fBlog\fR option.
-
-The --\fBlog\fR option specifies an alternate log file, \fIsrcfile\fR, to be compacted. This option is not valid in combination with the --\fBprivate\fR option.
-
+Deletes event records in the event log matching the specified filter,
+fills space freed by deleting the event records (by moving later records
+into the free space), and then truncates the log.
+The sequential order of events in the event log is maintained during this
+process and the record IDs of the remaining event records are left
+unchanged.
+See the \fBevlquery\fR man page for more information about the
+\fIfilter\fR.
+
+Before the compaction process begins, a backup copy of the log file is
+created if space is available.
+Following successful compaction, the backup copy is deleted.
+If the \fBevlogmgr\fR command is issued from the command line, and the
+user types Ctrl-C, then the active log file is restored from the backup
+copy.
+
+The --\fBforce\fR option should only be used as a last resort.
+If space is not available to create a backup (compressed or uncompressed),
+then this option forces compaction to occur without first creating a
+backup of the log file.
+If compaction does not complete successfully, then the \fBevlogmgr\fR
+command with the --\fBfix\fR option (see below) might be able to restore
+the log file to a usable state.
+
+The --\fBcompr-bak\fR option specifies that the backup log file created
+prior to compacting the original log file should be compressed.
+This option will take longer, but limited space might require its use.
 .TP
 -\fBf\fR, --\fBfix\fR 
-This option is used to repair a corrupted log file, and is required only in cases where the --\fBforce\fR option was used and the log management tasks terminated before completion.
+This option is used to repair a corrupted log file, and is required only
+in cases where the --\fBforce\fR option was used and the log management
+tasks terminated before completion.
+
+Each record in the event log is validated, and any records that are deemed
+invalid are deleted and replaced by valid records in the log.
+The command reports the total number of bytes deleted.
 
-Each record in the event log is validated, and any records that are deemed invalid are deleted and replaced by valid records in the log. The command reports the total number of bytes deleted.
-
-Some of the error messages that will indicate the need to repair the log include:
+Some of the error messages that will indicate the need to repair the log
+include:
 
 \(bu Input/output error (from evlview)
 .Pp
 
-\(bu Failed to count record for deletion 
-    (from evlogmgr -s)
+\(bu Failed to count record for deletion (from evlogmgr -s)
 .Pp
 
-\(bu Failed to compact log  (from evlogmgr -c)
+\(bu Failed to compact log (from evlogmgr -c)
 .Pp
-
-Unless the --\fBprivate\fR or --\fBlog\fR options are used, repair is performed on \fI@localstatedir@/eventlog\fR.
-
-The --\fBprivate\fR option specifies that repair should be performed on \fI@localstatedir@/privatelog\fR. This option is not valid in combination with the --\fBlog\fR option.
-
-The --\fBlog\fR option specifies an alternate log file, \fIsrcfile\fR, to be repaired. This option is not valid in combination with the --\fBprivate\fR option.
-
 .TP
 -\fBs\fR, --\fBshow-status\fR \fIfilter\fR 
-Shows how many records in the event log match the \fIfilter\fR, and shows the total number of records in the log. See the \fBevlquery\fR man page for more information about the \fIfilter\fR.
-
-Unless the --\fBprivate\fR or --\fBlog\fR options are used, status is shown for \fI@localstatedir@/eventlog\fR.
-
-The --\fBprivate\fR option specifies that status should be shown for \fI@localstatedir@/privatelog\fR. This option is not valid in combination with the --\fBlog\fR option.
-
-The --\fBlog\fR option specifies that status should be shown for an alternate log file, \fIsrcfile\fR. This option is not valid in combination with the --\fBprivate\fR option.
-
+Shows how many records in the event log match the \fIfilter\fR, and shows
+the total number of records in the log.
+See the \fBevlquery\fR man page for more information about the \fIfilter\fR.
 .SH "EXAMPLES"
-
 .TP
 Example 1
-Run \fBevlogmgr\fR -\fBc\fR from a cron job. See "man 5 crontab" for more details.
-
-# Daily at 2 AM remove recds older than 30 days
-
-0 2 * * * root /sbin/evlogmgr -c 'age > "30d"'
-
-      
-
-# Daily at 1 AM remove recds w/ sev=DEBUG
-
-0 1 * * * root /sbin/evlogmgr -c "severity=DEBUG"
-
-.TP
-Example 2
 Issuing the following command:
 
-   evlogmgr -c 'severity=DEBUG' -C 
+   evlogmgr -c 'severity=DEBUG' -C --log srcfile
    
 might result in the following events being appended to the log:
 
 recid=589, size=74, format=STRING, event_type=0x2, facility=LOGMGMT, 
 severity=NOTICE, uid=root, gid=root, pid=18653, pgrp=18653, 
 time=Thu 09 May 2002 12:59:08 PM PDT, flags=0x0, thread=0x400, processor=0
-Log compaction on @localstatedir@/eventlog starts at Thu May 09 12:59:08 2002
+Log compaction on /var/evlog/eventlog starts at Thu May 09 12:59:08 2002
           
 recid=591, size=69, format=STRING, event_type=0x3, facility=LOGMGMT, 
 severity=NOTICE, uid=root, gid=root, pid=18653, pgrp=18653, 
 time=Thu 09 May 2002 12:59:09 PM PDT, flags=0x0, thread=0x400, processor=0
-Log compaction on @localstatedir@/eventlog ended. 48 events were removed. 
+Log compaction on /var/evlog/eventlog ended. 48 events were removed.
 .TP
-Example 3
+Example 2
 Issuing the following command:
 
-   evlogmgr -s 'severity=DEBUG'
+   evlogmgr -s 'severity=DEBUG' --log srcfile
  
 might display the following:
 
@@ -135,25 +130,17 @@ might display the following:
    Number of records matching the filter is 48.
    Log file size would be reduced by 5.00 kbytes
 .TP
-Example 4
+Example 3
 Issuing the following command:
 
-   evlogmgr --fix
+   evlogmgr --fix --log srcfile
   
 might display the following:
 
   Found a corrupted event record. Trying to resync with next good record...
   Log repair finished, problem fixed.  Discarded 6 bytes. 
-.SH "FILES"
-
-.TP
-\fI@localstatedir@/eventlog\fR
-standard event log
-
-.TP
-\fI@localstatedir@/privatelog\fR
-private event log
-
 .SH "SEE ALSO"
 \fIevlquery man page\fR    Filter expression syntax rules
+\fIevlconfig man page\fR   New log creation
+\fIevlview man page\fR	   Log file display
 
Index: evlog-1.6.1/user/man/evlview.1
===================================================================
--- evlog-1.6.1.orig/user/man/evlview.1
+++ evlog-1.6.1/user/man/evlview.1
@@ -8,11 +8,10 @@
 .\" For questions regarding the modifications from the
 .\" docbook2man output, contact Dennis Grace at
 .\" <dgrace@us.ibm.com>.
-.TH "EVLVIEW" "1" "6 December 2002" "" ""
+.TH "EVLVIEW" "1" "12 Jul 2006" "" ""
 .SH NAME
 evlview \- View log events
 .SH SYNOPSIS
-
 \fBevlview --help\fR
 
  OR\fB
@@ -21,13 +20,12 @@ evlview \- View log events
 [\fI \fBoutput \fB] [ -f | --filter \fIfilter\fB ]
  [ -b |  --templates ] [ -B | --notemplates ]
 
-
-\fBinput\fR (defaults to \fI/var/evlog/eventlog\fR,
-or to \fI/var/evlog/privatelog\fR with \fB-p | --private\fR):\fB	
- [ -n | --new ][ -T | --timeout \fInsec\fB ][ -R | --recid \fIrid\fR ]
+\fBinput\fR (defaults to \fI/var/evlog/eventlog\fR, or to
+\fI/var/evlog/privatelog\fR with \fB-p | --private\fR):\fB
+ [ -n | --new ][ -T | --timeout \fIsec\fB ][ -R | --recid \fIrid\fR ]
   OR\fB
- [ -l | --log \fIsrclogfile\fB] [ -t | --tail \fInrec\fB ] 
- [ -r | --reverse ]\fR
+ [ -l | --log \fIsrclogfile\fB] OR [ -M | --multi \fIsrcmultifile\fB]
+ [ -t | --tail \fInrec\fB ] [ -r | --reverse ]\fR
 
 \fBoutput\fR (defaults to stdout):\fB 
  [ -o | --out \fIdestlogfile\fB ]\fR
@@ -42,200 +40,164 @@ or to \fI/var/evlog/privatelog\fR with \
 
 \fBformat_opts\fR:\fB
  [ -N | --newlines \fIn\fB ] [ -d | --datefmt \fIdate-format\fB ]
- 
 .SH "DESCRIPTION"
 .PP
-The \fBevlview\fR utility lets you view events
-from an event log, view events in real time, or read records from
-an event log and write the records to another file.
+The \fBevlview\fR utility lets you view events from one or more event log
+files, view events in real time, or read records from one or more event
+log files and write the records to another file.
 .SH "OPTIONS"
 .TP
 \fB-n, --new\fR
-Display only new events as they are
-logged. By default, events are read from the entire
-event log until the end of the log is reached. This
-option is not valid when \fB--log\fR specifies an inactive log file.
-.TP
-\fB-T, --timeout \fInsec\fB\fR
-Specifies the interval in seconds that
-the viewer should wait for the next event to be
-generated. If this interval passes with no new events,
-the viewer terminates. The interval restarts with each
-new event. By default, with the \fB--new\fR
-option, the viewer runs until it is killed. This
-option is valid only when the \fB--new\fR
-option is used.
+Display only new events as they are logged.
+By default, events are read from the entire event log until the end of
+the log is reached.
+This option is not valid when \fB--log\fR specifies an inactive log file.
+.TP
+\fB-T, --timeout \fIsec\fB\fR
+Specifies the time interval \fBsec\fR (in seconds) that the viewer should
+wait for the next event to be generated.
+If this interval passes with no new events, the viewer terminates.
+The interval restarts with each new event.
+By default, with the \fB--new\fR option, the viewer runs until it is
+killed.
+This option is valid only when the \fB--new\fR option is used.
 .TP
 \fB-R, --recid \fIrid\fB\fR
 Valid only with \fB--new\fR.
-Before displaying new records,
-display the end of the existing log,
-starting with the first record whose ID is greater than or equal to \fIrid\fR.
+Before displaying new records, display the end of the existing log,
+starting with the first record whose ID is greater than or equal to
+\fIrid\fR.
 .TP
 \fB-l, --log \fIsrclogfile\fB\fR
-Specifies the name of an alternate log
-file as the source of events \(em for example, the private
-log \fI/var/evlog/privatelog\fR. Events
-read from the private log file can be read only by users
-with the appropriate read permission.  If this option is
-not specified, events are read from the active system log,
-\fI/var/evlog/eventlog\fR.
+Specifies the name of an alternate log file as the source of events \(em
+for example, the private log \fI/var/evlog/privatelog\fR.
+Events read from the private log file can be read only by users with the
+appropriate read permission.
+If this option is not specified, events are read from the active system
+log, \fI/var/evlog/eventlog\fR.
+.TP
+\fB-M, --multi \fIsrcmultifile\fB\fR
+Specifies the pathname of a file containing log file pathnames, one per
+line.
+This is particularly useful when querying across a series of log files
+generated via the \fBevlconfig --newlog\fR command.
+The log files will processed in their order within \fBsrcmultifile\fR.
 .TP
 \fB-p, --private\fR
 Equivalent to \fB--log /var/evlog/privatelog\fR.
 .TP
 \fB-t, --tail \fInrec\fB\fR
-Specifies that \fBevlview\fR
-should read the last \fInrec\fR
-records in the event log file. If a filter is specified,
-then the last \fInrec\fR records
-are read that match the filter. 
+Specifies that \fBevlview\fR should read the last \fInrec\fR records in
+the event log file.
+If a filter is specified, then the last \fInrec\fR records are read that
+match the filter.
 .TP
 \fB-r, --reverse\fR
-Read events in reverse order, starting
-with the most recently written event. Default is to
-read starting with the oldest event in the event log. 
+Read events in reverse order, starting with the most recently written
+event.
+Default is to read starting with the oldest event in the event log.
 .TP
 \fB-o, --out \fIdestlogfile\fB\fR
-Specifies that event records should be
-appended to the specified
-\fIdestlogfile\fR instead of being
-displayed to stdout. This option is not valid with the
-\fB--formatstr\fR, \fB--formatfile\fR,
+Specifies that event records should be appended to the specified
+\fIdestlogfile\fR instead of being displayed to stdout.
+This option is not valid with the \fB--formatstr\fR, \fB--formatfile\fR,
 \fB--compact\fR, \fB--separator\fR, \fB--datefmt\fR, \fB--newlines\fR,
-\fB--neqval\fR,
-or \fB--syslog\fR
-options. 
+\fB--neqval\fR, or \fB--syslog\fR options.
 .TP
 \fB-S, --formatstr \fIformat-string\fB\fR
-Specifies an alternative format for events
-that are displayed (see Example 3). 
+Specifies an alternative format for events that are displayed (see
+Example 3).
 
-For the fixed portion of the event record, members
-are referenced by the attribute names defined in the POSIX
-standard: recid, size, format, event_type, facility,
-severity, uid, gid, pgrp, time, flags, thread, and
-processor.  
+For the fixed portion of the event record, members are referenced by the
+attribute names defined in the POSIX standard: recid, size, format,
+event_type, facility, severity, uid, gid, pgrp, time, flags, thread, and
+processor.
 
-An additional attribute is available, \fBhost\fR,
-which displays the name of the host that logged the event.
+An additional attribute is available, \fBhost\fR, which displays the name
+of the host that logged the event.
 
-For \fIlog_format\fR of
-STRING, %data% displays the variable-length data as
+For \fIlog_format\fR of STRING, %data% displays the variable-length data as
 the data string. 
 
-For \fIlog_format\fR of
-NODATA, %data% displays a NULL string. 
+For \fIlog_format\fR of NODATA, %data% displays a NULL string.
 
-For \fIlog_format\fR of
-BINARY, %data% displays the variable length data
-according to the associated formatting template, if any,
-or in hex dump format otherwise.
-
-If \fIlog_format\fR is
-BINARY and a formatting template exists for the event
-record, optional attributes in the variable-length
-portion can be referenced by attribute name as defined
-in the formatting template. However, the formatting
-string (if any) specified in
-\fIformat-string\fR is used
-instead of the formatting specification from the
-template. 
-
-If this option is not specified, then default
-formatting is used.  This option is not valid if specified
-along with \fB--out\fR,
-\fB--formatfile\fR,
-\fB--compact\fR, \fB--separator\fR,
-\fB--neqval\fR,
+For \fIlog_format\fR of BINARY, %data% displays the variable length data
+according to the associated formatting template, if any, or in hex dump
+format otherwise.
+
+If \fIlog_format\fR is BINARY and a formatting template exists for the
+event record, optional attributes in the variable-length portion can be
+referenced by attribute name as defined in the formatting template.
+However, the formatting string (if any) specified in \fIformat-string\fR
+is used instead of the formatting specification from the template.
+
+If this option is not specified, then default formatting is used.
+This option is not valid if specified along with \fB--out\fR,
+\fB--formatfile\fR, \fB--compact\fR, \fB--separator\fR, \fB--neqval\fR,
 or \fB--syslog\fR.
 .TP
 \fB-F, --formatfile \fIformat-file\fB\fR
-Performs the same actions as
-\fB--formatstr\fR, but the alternative
-format is read from
-\fIformat-file\fR. This option is
-not valid if specified along with
-\fB--out\fR,
-\fB--formatstr\fR,
-\fB--compact\fR,
-\fB--separator\fR,
-\fB--neqval\fR,
+Performs the same actions as \fB--formatstr\fR, but the alternative
+format is read from \fIformat-file\fR.
+This option is not valid if specified along with \fB--out\fR,
+\fB--formatstr\fR, \fB--compact\fR, \fB--separator\fR, \fB--neqval\fR,
 or \fB--syslog\fR.
 .TP
 \fB-c, --compact\fR
-Specifies that contents of the event
-record are displayed in a compact form. In compact form,
-the attribute names for attributes in the fixed portion
+Specifies that contents of the event record are displayed in a compact
+form.
+In compact form, the attribute names for attributes in the fixed portion
 of the event record are not displayed, only the values.
-This option cannot be used with
-\fB--formatstr\fR,
-\fB--formatfile\fR,
-\fB--syslog\fR, or
-\fB--out\fR.
+This option cannot be used with \fB--formatstr\fR, \fB--formatfile\fR,
+\fB--syslog\fR, or \fB--out\fR.
 .TP
 \fB-s, --separator \fIsep\fB\fR
-Specifies that the character string
-\fI'sep'\fR be used as the separator
-between attributes displayed by the viewer. The default
-separator is ','.  The separator string cannot exceed 20
-characters.  This option is not valid with
-\fB--formatstr\fR,
-\fB--formatfile\fR,
-\fB--syslog\fR, or
-\fB--out\fR. 
+Specifies that the character string \fI'sep'\fR be used as the separator
+between attributes displayed by the viewer.
+The default separator is ','.
+The separator string cannot exceed 20 characters.
+This option is not valid with \fB--formatstr\fR, \fB--formatfile\fR,
+\fB--syslog\fR, or \fB--out\fR.
 .TP
 \fB-N, --newlines \fIn\fB\fR
 When displaying records, ensures that there are exactly \fIn\fR newlines
 between records.
 For example, \fB-N 2\fR gets you exactly 1 blank line between records.
 \fIn\fR must be greater than zero.
-If a record ends in more than \fIn\fR newlines,
-then an appropriate number of those newlines will be omitted from the display.
-If this option is omitted,
-\fBevlview\fR ensures that there is at least one newline between records.
-This option is not valid with
-\fB--out\fR or \fB--syslog\fR.
+If a record ends in more than \fIn\fR newlines, then an appropriate
+number of those newlines will be omitted from the display.
+If this option is omitted, \fBevlview\fR ensures that there is at least
+one newline between records.
+This option is not valid with \fB--out\fR or \fB--syslog\fR.
 .TP
 \fB-d, --datefmt \fIdateformat\fB\fR
-Format the \fIlog_time\fR attribute
-according to the \fIdateformat\fR string,
-which is passed to the \fIstrftime\fR(3) function.
+Format the \fIlog_time\fR attribute according to the \fIdateformat\fR
+string, which is passed to the \fIstrftime\fR(3) function.
 The default format is "%c".
-This option is not valid with
-\fB--out\fR or \fB--syslog\fR.
+This option is not valid with \fB--out\fR or \fB--syslog\fR.
 .TP
 \fB-m, --syslog\fR
-Approximate the output format of the \fIsyslogd\fR(8) daemon:
-for each record displayed,
-print the timestamp, host name, and message.
-For multi-line messages, BINARY-format events,
-and events formatted by formatting templates,
-the output may not look much like \fIsyslogd\fR output.
-This option is not valid with the
-\fB--out\fR,
-\fB--formatstr\fR, \fB--formatfile\fR,
-\fB--nmeqval\fR,
-\fB--compact\fR, \fB--separator\fR, \fB--datefmt\fR, or \fB--newlines\fR
-options.
+Approximate the output format of the \fIsyslogd\fR(8) daemon: for each
+record displayed, print the timestamp, host name, and message.
+For multi-line messages, BINARY-format events, and events formatted by
+formatting templates, the output may not look much like \fIsyslogd\fR
+output.
+This option is not valid with the \fB--out\fR, \fB--formatstr\fR,
+\fB--formatfile\fR, \fB--nmeqval\fR, \fB--compact\fR, \fB--separator\fR,
+\fB--datefmt\fR, or \fB--newlines\fR options.
 .TP
 \fB-q, --nmeqval\fR
-For records that have associated templates,
-display the non-standard attributes in \fIname\fR=\fIvalue\fR format,
-one attribute per line.
-This option is not valid with the
-\fB--notemplates\fR,
-\fB--out\fR,
-\fB--formatstr\fR, \fB--formatfile\fR,
-or \fB--syslog\fR options.
+For records that have associated templates, display the non-standard
+attributes in \fIname\fR=\fIvalue\fR format, one attribute per line.
+This option is not valid with the \fB--notemplates\fR, \fB--out\fR,
+\fB--formatstr\fR, \fB--formatfile\fR, or \fB--syslog\fR options.
 .TP
 \fB-f, --filter \fIfilter\fB\fR
 Specifies a
 .\" filter name or
-filter (query)
-expression. Only events matching the \fIfilter\fR are displayed.
-See the \fIevlquery\fR man page for
-more information.
+filter (query) expression.
+Only events matching the \fIfilter\fR are displayed.
+See the \fIevlquery\fR man page for more information.
 .TP
 \fB-b, --templates\fR
 Forces non-standard attribute names to be accepted in the filter
@@ -243,14 +205,15 @@ expression supplied with the --filter op
 specified with the --formatstr or --formatfile option.
 A "non-standard" attribute is one defined via a formatting template
 rather than in the fixed portion of the event record.   
-For a particular event, if the named attribute does not exist,
-it will format as a null string,
-and references to it in the filter expression will evaluate to false.
+For a particular event, if the named attribute does not exist, it will
+format as a null string, and references to it in the filter expression
+will evaluate to false.
 .TP    
 \fB-B, --notemplates\fR
 Specifies that the evlview command should not attempt to locate
-formatting templates.  By default, evlview will attempt to use formatting
-templates when displaying records.  
+formatting templates.
+By default, evlview will attempt to use formatting templates when
+displaying records.
 .TP
 \fB-h, --help \fR
 Displays the usage statement.
@@ -262,8 +225,8 @@ evlview --filter 'facility==USER && data
    "interface reset"'
                 
 .fi
-might produce the following output (if there are 2
-matching events in the log):
+might produce the following output (if there are 2 matching events in
+the log):
 
 .nf
 recid=7214, size=31, format=STRING, event_type=0x3, facility=USER,
@@ -279,10 +242,10 @@ host=linux_host_1.foo.bar.com
 Eth/1 interface reset by user
 
 .fi
-Note that the date and time format shown in the examples 
-is based on the LANG environment variable not being set
-(or being set to "C").  For other settings, the format 
-will differ.  For example:
+Note that the date and time format shown in the examples is based on
+the LANG environment variable not being set (or being set to "C").
+For other settings, the format will differ.
+For example:
 .nf
 
      $export LANG=es_MX    (Spanish, Mexico)
@@ -323,26 +286,23 @@ and event type of %event_type:d% decimal
 might produce the following:
 .nf
 
-Logical unit number is 0x3
-for facility LOCAL1 and event type of 12565 decimal, 0x3115 hex
+Logical unit number is 0x3 for facility LOCAL1 and event type of 12565
+decimal, 0x3115 hex
 
 .fi
 Note that the \fB-b\fR option allows the non-standard attribute "lun" to
 be included with the \fB-f (--filter)\fR option.
 
-Also, note that due to the length of the formatting
-string, use of the \fB--formatfile\fR
-option would be preferable in practice instead of the
-\fB-S\fR or \fBformatstr\fR
-option. 
+Also, note that due to the length of the formatting string, use of the
+\fB--formatfile\fR option would be preferable in practice instead of the
+\fB-S\fR or \fBformatstr\fR option.
 .TP
 \fBExample 4.\fR
 .nf
 evlview -f 'age < "2h"'
 		
 .fi
-would display all events logged during the past
-2 hours.
+would display all events logged during the past 2 hours.
 .TP
 \fBExample 5.\fR
 .nf
@@ -352,9 +312,9 @@ evlview -n -R $nextrid -f 'flags & print
    --syslog >> /var/log/printks
 
 .fi
-would run continuously, appending to \fI/var/log/printks\fR
-all messages logged by the kernel's \fIprintk\fR() function,
-starting with the first message after the current boot.
+would run continuously, appending to \fI/var/log/printks\fR all messages
+logged by the kernel's \fIprintk\fR() function, starting with the first
+message after the current boot.
 The message format is that of the \fIsyslogd\fP daemon.
 .TP
 \fBExample 6.\fR
@@ -372,7 +332,6 @@ might display the following:
 .fi
 
 and demonstrates the use of the --datefmt option.
-
 .SH "FILES"
 .TP
 \fB\fI/var/evlog/eventlog\fB\fR
@@ -380,21 +339,11 @@ Standard Event log
 .TP
 \fB\fI/var/evlog/privatelog\fB\fR
 Private log
-
-
 .SH "SEE ALSO"
 \fIevlquery\fR man page    Filter expression syntax rules
 .br
 \fIstrftime\fR(3)\fR man page
-
 .SH "NOTES"
-When \fBevlview\fR is interrupted by a log-maintenance operation
-(e.g., when \fBevlogmgr\fR runs),
-\fBevlview\fR waits until the operation completes
-and then picks up where it had left off.
-This is intended to work even if the portion of the file where
-\fBevlview\fR was reading is deleted during log maintenance.
-If a timeout interval is specified with \fB--timeout\fR,
-and the timeout expires while \fBevlview\fR is waiting for
-completion of the log-maintenance operation,
-\fBevlview\fR terminates with an error message.
+If a log-maintenance operation (e.g., when \fBevlogmgr\fR runs) is in
+progress \fBevlview\fR waits until the operation completes and then
+picks up where it had left off.
Index: evlog-1.6.1/user/man/evlview.1.in
===================================================================
--- evlog-1.6.1.orig/user/man/evlview.1.in
+++ evlog-1.6.1/user/man/evlview.1.in
@@ -8,11 +8,10 @@
 .\" For questions regarding the modifications from the
 .\" docbook2man output, contact Dennis Grace at
 .\" <dgrace@us.ibm.com>.
-.TH "EVLVIEW" "1" "6 December 2002" "" ""
+.TH "EVLVIEW" "1" "12 Jul 2006" "" ""
 .SH NAME
 evlview \- View log events
 .SH SYNOPSIS
-
 \fBevlview --help\fR
 
  OR\fB
@@ -21,13 +20,12 @@ evlview \- View log events
 [\fI \fBoutput \fB] [ -f | --filter \fIfilter\fB ]
  [ -b |  --templates ] [ -B | --notemplates ]
 
-
-\fBinput\fR (defaults to \fI@localstatedir@/eventlog\fR,
-or to \fI@localstatedir@/privatelog\fR with \fB-p | --private\fR):\fB	
- [ -n | --new ][ -T | --timeout \fInsec\fB ][ -R | --recid \fIrid\fR ]
+\fBinput\fR (defaults to \fI@localstatedir@/eventlog\fR, or to
+\fI@localstatedir@/privatelog\fR with \fB-p | --private\fR):\fB
+ [ -n | --new ][ -T | --timeout \fIsec\fB ][ -R | --recid \fIrid\fR ]
   OR\fB
- [ -l | --log \fIsrclogfile\fB] [ -t | --tail \fInrec\fB ] 
- [ -r | --reverse ]\fR
+ [ -l | --log \fIsrclogfile\fB] OR [ -M | --multi \fIsrcmultifile\fB]
+ [ -t | --tail \fInrec\fB ] [ -r | --reverse ]\fR
 
 \fBoutput\fR (defaults to stdout):\fB 
  [ -o | --out \fIdestlogfile\fB ]\fR
@@ -42,200 +40,164 @@ or to \fI@localstatedir@/privatelog\fR w
 
 \fBformat_opts\fR:\fB
  [ -N | --newlines \fIn\fB ] [ -d | --datefmt \fIdate-format\fB ]
- 
 .SH "DESCRIPTION"
 .PP
-The \fBevlview\fR utility lets you view events
-from an event log, view events in real time, or read records from
-an event log and write the records to another file.
+The \fBevlview\fR utility lets you view events from an event log, view
+events in real time, or read records from an event log and write the
+records to another file.
 .SH "OPTIONS"
 .TP
 \fB-n, --new\fR
-Display only new events as they are
-logged. By default, events are read from the entire
-event log until the end of the log is reached. This
-option is not valid when \fB--log\fR specifies an inactive log file.
-.TP
-\fB-T, --timeout \fInsec\fB\fR
-Specifies the interval in seconds that
-the viewer should wait for the next event to be
-generated. If this interval passes with no new events,
-the viewer terminates. The interval restarts with each
-new event. By default, with the \fB--new\fR
-option, the viewer runs until it is killed. This
-option is valid only when the \fB--new\fR
-option is used.
+Display only new events as they are logged.
+By default, events are read from the entire event log until the end of
+the log is reached.
+This option is not valid when \fB--log\fR specifies an inactive log file.
+.TP
+\fB-T, --timeout \fIsec\fB\fR
+Specifies the time interval \fBsec\fR (in seconds) that the viewer should
+wait for the next event to be generated.
+If this interval passes with no new events, the viewer terminates.
+The interval restarts with each new event.
+By default, with the \fB--new\fR option, the viewer runs until it is
+killed.
+This option is valid only when the \fB--new\fR option is used.
 .TP
 \fB-R, --recid \fIrid\fB\fR
 Valid only with \fB--new\fR.
-Before displaying new records,
-display the end of the existing log,
-starting with the first record whose ID is greater than or equal to \fIrid\fR.
+Before displaying new records, display the end of the existing log,
+starting with the first record whose ID is greater than or equal to
+\fIrid\fR.
 .TP
 \fB-l, --log \fIsrclogfile\fB\fR
-Specifies the name of an alternate log
-file as the source of events \(em for example, the private
-log \fI@localstatedir@/privatelog\fR. Events
-read from the private log file can be read only by users
-with the appropriate read permission.  If this option is
-not specified, events are read from the active system log,
-\fI@localstatedir@/eventlog\fR.
+Specifies the name of an alternate log file as the source of events \(em
+for example, the private log \fI@localstatedir@/privatelog\fR.
+Events read from the private log file can be read only by users with the
+appropriate read permission.
+If this option is not specified, events are read from the active system
+log, \fI@localstatedir@/eventlog\fR.
+.TP
+\fB-M, --multi \fIsrcmultifile\fB\fR
+Specifies the pathname of a file containing log file pathnames, one per
+line.
+This is particularly useful when querying across a series of log files
+generated via the \fBevlconfig --newlog\fR command.
+The log files will processed in their order within \fBsrcmultifile\fR.
 .TP
 \fB-p, --private\fR
 Equivalent to \fB--log @localstatedir@/privatelog\fR.
 .TP
 \fB-t, --tail \fInrec\fB\fR
-Specifies that \fBevlview\fR
-should read the last \fInrec\fR
-records in the event log file. If a filter is specified,
-then the last \fInrec\fR records
-are read that match the filter. 
+Specifies that \fBevlview\fR should read the last \fInrec\fR records in
+the event log file.
+If a filter is specified, then the last \fInrec\fR records are read that
+match the filter.
 .TP
 \fB-r, --reverse\fR
-Read events in reverse order, starting
-with the most recently written event. Default is to
-read starting with the oldest event in the event log. 
+Read events in reverse order, starting with the most recently written
+event.
+Default is to read starting with the oldest event in the event log.
 .TP
 \fB-o, --out \fIdestlogfile\fB\fR
-Specifies that event records should be
-appended to the specified
-\fIdestlogfile\fR instead of being
-displayed to stdout. This option is not valid with the
-\fB--formatstr\fR, \fB--formatfile\fR,
+Specifies that event records should be appended to the specified
+\fIdestlogfile\fR instead of being displayed to stdout.
+This option is not valid with the \fB--formatstr\fR, \fB--formatfile\fR,
 \fB--compact\fR, \fB--separator\fR, \fB--datefmt\fR, \fB--newlines\fR,
-\fB--neqval\fR,
-or \fB--syslog\fR
-options. 
+\fB--neqval\fR, or \fB--syslog\fR options.
 .TP
 \fB-S, --formatstr \fIformat-string\fB\fR
-Specifies an alternative format for events
-that are displayed (see Example 3). 
+Specifies an alternative format for events that are displayed (see
+Example 3).
 
-For the fixed portion of the event record, members
-are referenced by the attribute names defined in the POSIX
-standard: recid, size, format, event_type, facility,
-severity, uid, gid, pgrp, time, flags, thread, and
-processor.  
+For the fixed portion of the event record, members are referenced by the
+attribute names defined in the POSIX standard: recid, size, format,
+event_type, facility, severity, uid, gid, pgrp, time, flags, thread, and
+processor.
 
-An additional attribute is available, \fBhost\fR,
-which displays the name of the host that logged the event.
+An additional attribute is available, \fBhost\fR, which displays the name
+of the host that logged the event.
 
-For \fIlog_format\fR of
-STRING, %data% displays the variable-length data as
+For \fIlog_format\fR of STRING, %data% displays the variable-length data as
 the data string. 
 
-For \fIlog_format\fR of
-NODATA, %data% displays a NULL string. 
+For \fIlog_format\fR of NODATA, %data% displays a NULL string.
 
-For \fIlog_format\fR of
-BINARY, %data% displays the variable length data
-according to the associated formatting template, if any,
-or in hex dump format otherwise.
-
-If \fIlog_format\fR is
-BINARY and a formatting template exists for the event
-record, optional attributes in the variable-length
-portion can be referenced by attribute name as defined
-in the formatting template. However, the formatting
-string (if any) specified in
-\fIformat-string\fR is used
-instead of the formatting specification from the
-template. 
-
-If this option is not specified, then default
-formatting is used.  This option is not valid if specified
-along with \fB--out\fR,
-\fB--formatfile\fR,
-\fB--compact\fR, \fB--separator\fR,
-\fB--neqval\fR,
+For \fIlog_format\fR of BINARY, %data% displays the variable length data
+according to the associated formatting template, if any, or in hex dump
+format otherwise.
+
+If \fIlog_format\fR is BINARY and a formatting template exists for the
+event record, optional attributes in the variable-length portion can be
+referenced by attribute name as defined in the formatting template.
+However, the formatting string (if any) specified in \fIformat-string\fR
+is used instead of the formatting specification from the template.
+
+If this option is not specified, then default formatting is used.
+This option is not valid if specified along with \fB--out\fR,
+\fB--formatfile\fR, \fB--compact\fR, \fB--separator\fR, \fB--neqval\fR,
 or \fB--syslog\fR.
 .TP
 \fB-F, --formatfile \fIformat-file\fB\fR
-Performs the same actions as
-\fB--formatstr\fR, but the alternative
-format is read from
-\fIformat-file\fR. This option is
-not valid if specified along with
-\fB--out\fR,
-\fB--formatstr\fR,
-\fB--compact\fR,
-\fB--separator\fR,
-\fB--neqval\fR,
+Performs the same actions as \fB--formatstr\fR, but the alternative
+format is read from \fIformat-file\fR.
+This option is not valid if specified along with \fB--out\fR,
+\fB--formatstr\fR, \fB--compact\fR, \fB--separator\fR, \fB--neqval\fR,
 or \fB--syslog\fR.
 .TP
 \fB-c, --compact\fR
-Specifies that contents of the event
-record are displayed in a compact form. In compact form,
-the attribute names for attributes in the fixed portion
+Specifies that contents of the event record are displayed in a compact
+form.
+In compact form, the attribute names for attributes in the fixed portion
 of the event record are not displayed, only the values.
-This option cannot be used with
-\fB--formatstr\fR,
-\fB--formatfile\fR,
-\fB--syslog\fR, or
-\fB--out\fR.
+This option cannot be used with \fB--formatstr\fR, \fB--formatfile\fR,
+\fB--syslog\fR, or \fB--out\fR.
 .TP
 \fB-s, --separator \fIsep\fB\fR
-Specifies that the character string
-\fI'sep'\fR be used as the separator
-between attributes displayed by the viewer. The default
-separator is ','.  The separator string cannot exceed 20
-characters.  This option is not valid with
-\fB--formatstr\fR,
-\fB--formatfile\fR,
-\fB--syslog\fR, or
-\fB--out\fR. 
+Specifies that the character string \fI'sep'\fR be used as the separator
+between attributes displayed by the viewer.
+The default separator is ','.
+The separator string cannot exceed 20 characters.
+This option is not valid with \fB--formatstr\fR, \fB--formatfile\fR,
+\fB--syslog\fR, or \fB--out\fR.
 .TP
 \fB-N, --newlines \fIn\fB\fR
 When displaying records, ensures that there are exactly \fIn\fR newlines
 between records.
 For example, \fB-N 2\fR gets you exactly 1 blank line between records.
 \fIn\fR must be greater than zero.
-If a record ends in more than \fIn\fR newlines,
-then an appropriate number of those newlines will be omitted from the display.
-If this option is omitted,
-\fBevlview\fR ensures that there is at least one newline between records.
-This option is not valid with
-\fB--out\fR or \fB--syslog\fR.
+If a record ends in more than \fIn\fR newlines, then an appropriate
+number of those newlines will be omitted from the display.
+If this option is omitted, \fBevlview\fR ensures that there is at least
+one newline between records.
+This option is not valid with \fB--out\fR or \fB--syslog\fR.
 .TP
 \fB-d, --datefmt \fIdateformat\fB\fR
-Format the \fIlog_time\fR attribute
-according to the \fIdateformat\fR string,
-which is passed to the \fIstrftime\fR(3) function.
+Format the \fIlog_time\fR attribute according to the \fIdateformat\fR
+string, which is passed to the \fIstrftime\fR(3) function.
 The default format is "%c".
-This option is not valid with
-\fB--out\fR or \fB--syslog\fR.
+This option is not valid with \fB--out\fR or \fB--syslog\fR.
 .TP
 \fB-m, --syslog\fR
-Approximate the output format of the \fIsyslogd\fR(8) daemon:
-for each record displayed,
-print the timestamp, host name, and message.
-For multi-line messages, BINARY-format events,
-and events formatted by formatting templates,
-the output may not look much like \fIsyslogd\fR output.
-This option is not valid with the
-\fB--out\fR,
-\fB--formatstr\fR, \fB--formatfile\fR,
-\fB--nmeqval\fR,
-\fB--compact\fR, \fB--separator\fR, \fB--datefmt\fR, or \fB--newlines\fR
-options.
+Approximate the output format of the \fIsyslogd\fR(8) daemon: for each
+record displayed, print the timestamp, host name, and message.
+For multi-line messages, BINARY-format events, and events formatted by
+formatting templates, the output may not look much like \fIsyslogd\fR
+output.
+This option is not valid with the \fB--out\fR, \fB--formatstr\fR,
+\fB--formatfile\fR, \fB--nmeqval\fR, \fB--compact\fR, \fB--separator\fR,
+\fB--datefmt\fR, or \fB--newlines\fR options.
 .TP
 \fB-q, --nmeqval\fR
-For records that have associated templates,
-display the non-standard attributes in \fIname\fR=\fIvalue\fR format,
-one attribute per line.
-This option is not valid with the
-\fB--notemplates\fR,
-\fB--out\fR,
-\fB--formatstr\fR, \fB--formatfile\fR,
-or \fB--syslog\fR options.
+For records that have associated templates, display the non-standard
+attributes in \fIname\fR=\fIvalue\fR format, one attribute per line.
+This option is not valid with the \fB--notemplates\fR, \fB--out\fR,
+\fB--formatstr\fR, \fB--formatfile\fR, or \fB--syslog\fR options.
 .TP
 \fB-f, --filter \fIfilter\fB\fR
 Specifies a
 .\" filter name or
-filter (query)
-expression. Only events matching the \fIfilter\fR are displayed.
-See the \fIevlquery\fR man page for
-more information.
+filter (query) expression.
+Only events matching the \fIfilter\fR are displayed.
+See the \fIevlquery\fR man page for more information.
 .TP
 \fB-b, --templates\fR
 Forces non-standard attribute names to be accepted in the filter
@@ -243,14 +205,15 @@ expression supplied with the --filter op
 specified with the --formatstr or --formatfile option.
 A "non-standard" attribute is one defined via a formatting template
 rather than in the fixed portion of the event record.   
-For a particular event, if the named attribute does not exist,
-it will format as a null string,
-and references to it in the filter expression will evaluate to false.
+For a particular event, if the named attribute does not exist, it will
+format as a null string, and references to it in the filter expression
+will evaluate to false.
 .TP    
 \fB-B, --notemplates\fR
 Specifies that the evlview command should not attempt to locate
-formatting templates.  By default, evlview will attempt to use formatting
-templates when displaying records.  
+formatting templates.
+By default, evlview will attempt to use formatting templates when
+displaying records.
 .TP
 \fB-h, --help \fR
 Displays the usage statement.
@@ -262,8 +225,8 @@ evlview --filter 'facility==USER && data
    "interface reset"'
                 
 .fi
-might produce the following output (if there are 2
-matching events in the log):
+might produce the following output (if there are 2 matching events in
+the log):
 
 .nf
 recid=7214, size=31, format=STRING, event_type=0x3, facility=USER,
@@ -279,10 +242,10 @@ host=linux_host_1.foo.bar.com
 Eth/1 interface reset by user
 
 .fi
-Note that the date and time format shown in the examples 
-is based on the LANG environment variable not being set
-(or being set to "C").  For other settings, the format 
-will differ.  For example:
+Note that the date and time format shown in the examples is based on
+the LANG environment variable not being set (or being set to "C").
+For other settings, the format will differ.
+For example:
 .nf
 
      $export LANG=es_MX    (Spanish, Mexico)
@@ -323,26 +286,23 @@ and event type of %event_type:d% decimal
 might produce the following:
 .nf
 
-Logical unit number is 0x3
-for facility LOCAL1 and event type of 12565 decimal, 0x3115 hex
+Logical unit number is 0x3 for facility LOCAL1 and event type of 12565
+decimal, 0x3115 hex
 
 .fi
 Note that the \fB-b\fR option allows the non-standard attribute "lun" to
 be included with the \fB-f (--filter)\fR option.
 
-Also, note that due to the length of the formatting
-string, use of the \fB--formatfile\fR
-option would be preferable in practice instead of the
-\fB-S\fR or \fBformatstr\fR
-option. 
+Also, note that due to the length of the formatting string, use of the
+\fB--formatfile\fR option would be preferable in practice instead of the
+\fB-S\fR or \fBformatstr\fR option.
 .TP
 \fBExample 4.\fR
 .nf
 evlview -f 'age < "2h"'
 		
 .fi
-would display all events logged during the past
-2 hours.
+would display all events logged during the past 2 hours.
 .TP
 \fBExample 5.\fR
 .nf
@@ -352,9 +312,9 @@ evlview -n -R $nextrid -f 'flags & print
    --syslog >> /var/log/printks
 
 .fi
-would run continuously, appending to \fI/var/log/printks\fR
-all messages logged by the kernel's \fIprintk\fR() function,
-starting with the first message after the current boot.
+would run continuously, appending to \fI/var/log/printks\fR all messages
+logged by the kernel's \fIprintk\fR() function, starting with the first
+message after the current boot.
 The message format is that of the \fIsyslogd\fP daemon.
 .TP
 \fBExample 6.\fR
@@ -372,7 +332,6 @@ might display the following:
 .fi
 
 and demonstrates the use of the --datefmt option.
-
 .SH "FILES"
 .TP
 \fB\fI@localstatedir@/eventlog\fB\fR
@@ -380,21 +339,11 @@ Standard Event log
 .TP
 \fB\fI@localstatedir@/privatelog\fB\fR
 Private log
-
-
 .SH "SEE ALSO"
 \fIevlquery\fR man page    Filter expression syntax rules
 .br
 \fIstrftime\fR(3)\fR man page
-
 .SH "NOTES"
-When \fBevlview\fR is interrupted by a log-maintenance operation
-(e.g., when \fBevlogmgr\fR runs),
-\fBevlview\fR waits until the operation completes
-and then picks up where it had left off.
-This is intended to work even if the portion of the file where
-\fBevlview\fR was reading is deleted during log maintenance.
-If a timeout interval is specified with \fB--timeout\fR,
-and the timeout expires while \fBevlview\fR is waiting for
-completion of the log-maintenance operation,
-\fBevlview\fR terminates with an error message.
+If a log-maintenance operation (e.g., when \fBevlogmgr\fR runs) is in
+progress \fBevlview\fR waits until the operation completes and then
+picks up where it had left off.
